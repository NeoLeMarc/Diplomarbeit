\chapter{Analyse}\label{Analyse}

In diesem Kapitel wird eine Analyse der Problemstellung dieser Diplomarbeit vorgenommen. Hierzu 
werden zunächst die Anforderungen analysiert, die an ein kabelloses System zur Überwachung von 
Patienten gestellt werden. Danach werden die eingesetzten Hardwarebausteine, konkret der
\emph{ADuC-Mikrocontroller} sowie das \emph{ZigBee-Modul} der Firma \emph{Atmel} 
inklusive der dazugehörigen \emph{SerialNet-Firmware} vorgestellt und untersucht. Hierbei 
werden häufig auftretende Probleme aufgezeigt und allgemeine Lösungen erarbeitet. Diese
Lösungen werden in den späteren Kapitel als Grundlage für den Entwurf und die Implementierung
der fertigen Lösung dienen.

\section{Anforderungen an ein kabelloses System zur Überwachung von Patienten}\label{Anforderungen}
    Nach Betrachtung des Standes der Technik ergeben sich folgende Anforderungen
    an das zu entwickelnde System:
    
    \begin{itemize}
        \item{Kompatibilität:} Die zu entwickelnde Lösung soll mit dem \emph{Erste-Hilfe-Sensor}
                               zusammenarbeiten. Hierzu ist es erforderlich, dass der Mikrocontroller
                               des Sensors in die Lage versetzt wird, mit dem Sensornetzwerk zu
                               kommunizieren.
        \item{Empfangen von Vitaldaten:} Das System muss in der Lage sein, Vitaldaten und Alarme  
                                         von den Sensoren zu empfangen. Diese müssen möglichst zeitnah
                                         zugestellt und angezeigt werden. Bei bestehen der Netzwerkverbindung
                                         sollen keine Nachrichten verloren gehen. 
        \item{Senden von Befehlen:} Das System soll in der Lage sein, Befehle an die Sensoren zu senden.
                                    Diese sollen auf die empfangenen Befehle entsprechend reagieren. Es
                                    soll möglich sein, neue Befehle zu einem späteren Zeitpunkt hinzuzufügen.
        \item{Skalierbarkeit:} Das System soll sowohl in Anzahl der Sensoren als auch in der räumlichen 
                               Ausdehnung (Reichweite) skalierbar sein. Es sollen sowohl sehr kleine Netzwerke
                               als auch große Netzwerke mit mehreren hundert Knoten realisierbar sein.
        \item{Kosteneffizienz:} Die Kosten für die Erweiterung der Sensoren sollen möglichst gering sein.
        \item{Niedriger Strombedarf:} Der Strombedarf der einzelnen Sensoren muss so gering sein, dass
                                         der Betrieb über eine handliche Batterie über einen längeren 
                                         Zeitraum möglich ist. Ideal wäre, wenn sich eine Laufzeit von
                                         mindestens 12 Stunden mit einer einzelnen Knopfzelle erreichen
                                         liesse.
        \item{Stabilität:} Das System soll möglichst unempfindlich gegenüber Störungen sein. Bei einfachen
                           Störungen des Funkverkehrs sollen verlorene Pakete neu Übertragen werden.
                           Schlägt diese Übertragung wiederholt fehl, soll eine Warnmeldung an der Überwachungsstation 
                           angezeigt werden. Es soll ebenfalls gewarnt werden, wenn ein Sensor die Netzwerkverbindung
                           verloren hat oder aus anderen Gründen (z.B. leere Batterie) nicht mehr erreichbar ist.
        \item{Erweiterbarkeit:} Das System soll softwareseitig erweiterbar sein. Insbesondere soll es 
                            möglich sein, ohne Veränderungen an der Software Schnittstellen (z.B. in Form einer
                            Weboberfläche) zu anderen Systemen hinzuzufügen. 
        \item{Anpassbarkeit:} Das System soll an sich verändernde Rahmenbedingungen anpassbar sein. Insbesondere
                          sollen alle technischen Details des Funkprotokolls so gekapselt werden, dass ein
                          Austausch des Funkprotokolls lediglich an einer Stelle des Systems Änderungen
                          erfordert.
    \end{itemize}

\section{Der \emph{Analog Devices ADuC702X}-Mi\-kro\-con\-trol\-ler}
    \Abbildungps{!htb}{1}{diagramme/aduc_blockdiagramm.pdf}{aduc_blockdiagramm}{Blockdiagramm des \emph{ADuC7026}-Mikrocontrollers (Quelle: Analog Devices)}
    \nomenclature{ADuC}{Mikrocontrollerfamilie der Firma \emph{Analog Devices} auf \emph{ARM}-Basis.}
    \nomenclature{ARM}{RISC-Prozessorarchitektur, die von verschiedene Herstellern in Lizenz gefertigt wird.}
    \nomenclature{RISC}{Reduced Instruction Set Computer.}
    \nomenclature{A/D-Wandler}{Analog-zu-Digital-Wandler.}
    \nomenclature{DAC}{Digital zu Analog Wandler.}
    \nomenclature{MIPS}{Million Instructions per Second}
    \nomenclature{MSPS}{Million Samples per Second}
    \nomenclature{SPI}{Serieller Bus zum Anbinden von Komponenten an Mikrocontroller.}
    \nomenclature{$I^2C$}{Serieller Bus zum Anbinden von Komponenten an Mikrocontroller.}
    \nomenclature{SRAM}{Statischer \emph{RAM} auf Basis von sogenannten Flip-Flop-Bausteinen. Benötigt im Gegensatz
                        zu \emph{DRAM} kein periodisches Auffrischen des Inhalts.}
    \nomenclature{DRAM}{Dynamischer \emph{RAM}, der periodisch aufgefrischt werden muss, um seinen Inhalt zu erhalten.}
    \nomenclature{RAM}{Random Access Memory}
    \nomenclature{PLA}{Programmierbare logische Anordnung}
    \nomenclature{HF}{Hochfrequenz}
    \nomenclature{UART}{Universal Asynchronous Receiver Transmitter}
    \nomenclature{AT-Befehlssatz}{Satz von Befehlen, der ursprünglich zur Steuerung von Modems entwickelt wurde.}
    \nomenclature{Sample}{Siehe Sampling.}
    \nomenclature{Sampling}{Umwandlung eines analogen in ein digitales Signal mittels Abtastung.}

                           

    Zentrale Komponente des \emph{Erste-Hilfe-Sensors}, welcher die Grundlage für die Sensoren im zu entwerfenden Netzwerk
    bildet, ist der \emph{ADuC-7022}-Mikrocontroller. Es handelt sich hierbei um einen Vertreter einer ganzen Familie
    von Mikrocontrollern der Firma \emph{Analog Devices}. Es folgt eine kurze Übersicht über die Eigenschaften
    dieser Mikrocontrollerfamilie.

    \subsection{Beschreibung}
        Mit der \emph{ADuC702X}-Familie bietet die Firma \emph{Analog Devices} eine Serie voll integrierter 
        Mikrocontroller auf Basis der \emph{ARM7}-Architektur an. Diese Mikrocontroller zeichnen sich insbesondere 
        durch ihre hohe Anzahl an A/D-Wandler-Kanälen aus. So verfügt das Modell \emph{ADuC7026} beispielsweise
        über 16 A/D-Wandler-Kanäle mit einer Abtastrate von einer Million \emph{Samples} pro Sekunde bei einer 
        Auflösung von 12~Bit. Damit bietet jeder der 16 Kanäle eine Datenrate, die etwa dem 17fachen einer 
        gewöhnlichen Audio-CD entspricht.  Der Mikrocontroller selbst bietet bei einer Frequenz von 
        41,78~MHz eine maximale Leistung von 41 Millionen Befehlen pro Sekunde (\emph{MIPS}). 
        Zusätzlich sind auf dem Chip 8~kB \emph{SRAM} sowie 62~kB \emph{Flash}-Speicher vorhanden. Bei den Modellen
        \emph{ADuC7026} und \emph{ADuC7027} ist zusätzlich ein externer Speicherbus vorhanden, über den bis zu 512kB 
        zusätzlicher \emph{SRAM} angeschlossen werden kann. Bei größerem Speicherbedarf besteht die Möglichkeit, über 
        \emph{SPI} oder \emph{$I^2C$} weiteren \emph{SRAM} oder \emph{Flash}-Speicher anzuschliessen. \cite{aduc_datasheet}

    \subsection{Peripherie}
        In die Mikrocontroller der \emph{ADuC-702X}-Familie ist standardmäßig folgende Peripherie integriert:

        \begin{itemize}
            \item{AD-Wandler:} Bis zu 16 Kanäle mit einer maximalen Abtastrate von 1~\emph{MSPS} bei einer Auflösung von 
                               12~Bit.
            \item{DA-Wandler:} Je nach Typ 2, 3 oder vier Kanäle, mit einer Ausgangsspannung zwischen 0 und 2,5~V mit einer
                               Auflösung von 12~Bit.
            \item{PWM-Generator:} Flexibler 3-Phasen Pulsweitenmodulator (\emph{PWM}), der bis zu 3 Signalpaare 
                                  gleichzeitig generieren kann.
            \item{UART-Interface:} Serielle Schnittstelle (\emph{UART}) mit \emph{TTL}-Pegel.
            \item{SPI-Bus:} Schnittstelle zum Anbinden von bis zu 255 weiteren Peripheriekomponenten.
            \item{$I^2C-Bus$:} 2 \emph{$I^2C$}-Schnittstellen zur Anbindung weiterer Peripherie.
            \item{PLA:} 2 Blöcke mit jeweils 8 \emph{PLA}-Elementen.
            \item{Timer:} 4 Allzwecktimer/Zähler.
        \end{itemize}
        
        Die einzelnen Modelle der \emph{ADuC-702X}-Familie unterscheiden sich vor allem durch die Anzahl vorhandener 
        Pins. Bei dem kleinsten Modell \emph{ADuC-7019} stehen lediglich 40 Pins, beim größten 80 Pins zur Verfügung. 
        Diese Pins sind zudem mehrfach belegt. Daher ist es nicht möglich, die gesamte Peripherie gleichzeitig zu 
        verwenden. Je nach Anforderung ist ggf. die Verwendung eines größeren Modells notwendig. 


\section{Die Atmel-\emph{ZigBit}-Familie}

    Nachdem die Entscheidung getroffen wurde, \emph{ZigBee} als Funktechnologie für das Netzwerk zu verwenden, muss
    nun noch ein geeignetes Hardwarebauteil gefunden werden. Da die Herstellung von \emph{HF}\footnote{Hochfrequenz}-Komponenten
    eine sehr langwierige und komplexe Aufgabe ist, wurde die Entscheidung getroffen, ein komplett integriertes Modul zu verwenden, bei dem bereits alle 
    \emph{HF}-Komponenten und Antenne aufgebracht sind. Passende Lösungen waren von den Firmen \emph{Digi}, 
    \emph{Mikrochip}, \emph{Radicrafts} und \emph{Atmel} verfügbar. Letztendlich wurde die Entscheidung für
    ein Modul der Firma \emph{Atmel} getroffen, da diese nicht nur die günstigsten betrachteten Module,
    sondern mit der Ansteuerung über \emph{UART} mittels \emph{AT-Befehlen} auch am einfachsten anzusteuern waren.
    Der hier verwendete Modultyp soll nachfolgend kurz vorgestellt werden.

    \subsection{Hardware}
        \Abbildungps{!htb}{1}{diagramme/zigbit_blockdiagramm.pdf}{zigbit_blockdiagramm}{Blockdiagramm des ZigBit-24-A2R-Moduls (Quelle: Atmel)}

        Atmel bietet unter dem Namen \emph{ZigBit} eine Palette von ZigBee-Modulen an. Diese Module sind in der
        Ansteuerung identisch, unterscheiden sich jedoch vor allem in ihrer Reichweite. Unter der Bezeichnung 
        \emph{ATZB-24-A2R} wird ein Modul für kurze Reichweiten angeboten. Besonderheit an diesem Modul ist, 
        dass es bereits über zwei integrierte Antennen verfügt, so dass für den Betrieb keine weiteren Bauteile
        notwendig sind.
        Die \emph{ZigBit}-Module enthalten einen \emph{IEEE 802.15.4-Transceiver}, einen 
        \emph{ATmega1281}-Mikrocontroller sowie einen
        128kB großen \emph{Flash}-Speicher. Das Modul kann mittels \emph{UART}, \emph{SPI} oder \emph{$I^2C$} angesteuert 
        werden. \cite{zigbit_datasheet}

    \subsection{Firmware}
        \subsubsection{Bitcloud}
            \nomenclature{SDK}{Software Development Kit}
            \emph{BitCloud}  ist ein \emph{ZigBee-Pro}-zertifizierter \emph{Softwarestack} von Atmel. Es werden die 
            Module der \emph{ZigBit}-Familie
            sowie die \emph{RZRAVEN-Evaluationskits} unterstützt. \emph{BitCloud} ist hierbei keine fertige
            \emph{Firmware}, sondern 
            Teil eines \emph{Software Development Kits (SDK)}, das dazu dient, Anwender beim schnellen und einfachen Entwickeln eigener 
            \emph{Firmware} zu unterstützen. Für Anwender, die selbst keine \emph{Firmware} implementieren möchten, 
            stellt das im folgenden Abschnitt beschriebene \emph{SerialNet} eine Alternative dar.

        \subsubsection{SerialNet}
            \nomenclature{IO-Port}{Input/Output-Port}

                \emph{SerialNet} ist eine \emph{BitCloud}-basierte \emph{Firmware}, die von Atmel als fertiges Image\footnote{Binäres Speicherabbild,
                    das ohne Anpassung in den Speicher des \emph{ZigBit}-Moduls programmiert werden kann.} angeboten
                wird. Dieses kann auf dem \emph{ZigBit}-Modul installiert werden, wodurch die Notwendigkeit der 
                Eigenentwicklung entfällt. \emph{SerialNet} bietet ein einfaches serielles Interface, das sich mit
                Hilfe von \emph{AT-Befehlen}\footnote{Der AT-Befehlssatz war früher zur Steuerung von Modems weit 
                verbreitet.} 
                steuern lässt. Der Befehlssatz bietet Zugriff auf fast alle Module des \emph{ZigBit}-Moduls wie z.B. das
                Versenden und Empfangen von Daten, das Schalten von \emph{IO-Ports} eines entfernten 
                \emph{ZigBit}-Moduls sowie die
                Konfiguration des Energiesparmodus. Nicht möglich ist derzeit die Verwendung der im \emph{ZigBee}-Standard
                definierten \emph{AES}-Verschlüsselung, so dass eine Datenübertragung derzeit nur 
                unverschlüsselt erfolgen kann.
                Daher müssen für den produktiven Einsatz weitere Sicherheitsmaßnahmen ergriffen werden. Wie diese aussehen 
                können, ist in Abschnitt~\ref{Sicherheit} beschrieben. 

            \paragraph{SerialNet AT-Protokoll}

                \Abbildungps{!htb}{1.00}{diagramme/serialnet_protokoll.pdf}{serialnet_protokoll}{Darstellung des SerialNet-Protokolls als Zustandsautomat}

                Das SerialNet AT-Protokoll lässt sich vereinfacht als Zustandsautomat mit 3 Zuständen darstellen
                (vgl. Abbildung~\ref{serialnet_protokoll})\footnote{Zur exakten Darstellung müssten weitere 
                    Zustände eingeführt werden, die das Bearbeiten von Befehlen im \emph{offline}-Modus repräsentieren. 
                    Außerdem wird der Übergang von \emph{offline} zu \emph{online} eigentlich durch ein 
                    \emph{EVENT\_JOINED}-Ereignis ausgelöst, und müsste daher durch einen Epsilon-Übergang dargestellt
                    werden. Diese Details sind jedoch für das Verständnis der prinzipiellen Funktionsweise des 
                    Befehlssatzes unwesentlich.}:

                \begin{itemize}
                    \item{\emph{offline}:} Es besteht keine Verbindung zu einem \emph{ZigBee}-Netzwerk. Befehle
                                    zur Kommunikation mit anderen Knoten sind nicht verfügbar. 
                                    Ein Zugriff auf die Konfiguration der Netzwerkparameter wie 
                                    Netzwerk- und Hardwareadresse ist verfügbar. 

                    \item{\emph{online}:} Das Modul ist betriebsbereit, mit einem Netzwerk verbunden und wartet
                                   auf Befehle. Befehle zur Kommunnikation mit anderen Knoten stehen zur
                                   Verfügung, Befehle zur Kommunikation der Netzwerkparameter sind gesperrt.

                    \item{\emph{busy}:} Das Modul ist mit der Bearbeitung eines Befehls beschäftigt. Es stehen
                                 keine Befehle zur Verfügung\,--\,jedoch können jederzeit Ereignisse 
                                 empfangen werden.
                \end{itemize}
                                    
                Grundsätzlich ist das \emph{SerialNet}-Protokoll synchron: Ein Befehl wird immer mit einem der beiden 
                Ergebniscodes \emph{OK} und \emph{ERROR} beantwortet. Bei einigen Befehlen wie z.B. \emph{AT+WCHILDREN}
                kann zusätzlich zum Ergebniscode eine ggf. sogar mehrzeilige Antwort erfolgen. Eine Antwort wird immer
                durch Ausgabe eines Ergebniscodes beendet. Neben dieser synchronen Befehl-Antwort-Folge können jedoch
                jederzeit auch asynchrone Events auftreten. Hierauf muss bei der Entwicklung eines Treibers zur 
                Ansteuerung des Moduls besonders geachtet werden. Die wichtigsten \emph{SerialNet}-Befehle, ihre
                Anwendbarkeit sowie die Art der Antwort sind in Tabelle~\ref{serialnet_befehle} dargestellt.
                Tabelle~\ref{serialnet_events} beinhaltet die wichtigsten \emph{SerialNet}-Events.

                \begin{table}
                    \begin{tabular}{llll}
                        \textbf{Befehl}  & \textbf{Beschreibung}  & \textbf{Antwort} & \textbf{Anwendbark.}\\

                        ATD           & Versenden von Daten               & Einfach & online-Zustand \\
                        ATR           & Entfernten Befehl ausführen       & Komplex & online-Zustand \\
                        AT+WCHILDREN  & Liste aller untergeordneter Nodes & Komplex & nur auf FFD\\
                        AT+WPANID     & Setzen der PAN-Adresse            & Einfach & offline-Zustand \\
                        AT+WCHMASK    & Setzen der Kanalmaske             & Einfach & offline-Zustand \\
                        AT+WLEAVE     & Netzwerk verlassen                & Einfach & online-Zustand \\
                        AT+WJOIN      & Netzwerk beitreten                & Einfach & offline-Zustand \\
                        AT+WAUTONET   & Netzwerk automatisch beitreten    & Einfach & offline-Zustand \\
                        AT+WROLE      & Rolle im Netzwerk konfigurieren   & Einfach & offline-Zustand \\
                        AT+WPWR       & Powermanagement konfigurieren     & Einfach & offline-Zustand \\
                        AT+WSRC       & Netzwerkadresse konfigurieren     & Einfach & offline-Zustand \\
                        AT+GSN        & Hardwareadresse konfigurieren     & Einfach & offline-Zustand \\
                        AT+WWAIT      & Wartezeit auf Parameter für ATD   & Einfach & offline-Zustand \\
                    \end{tabular}
                    \caption{Übersicht der wichtigsten \emph{SerialNet}-Befehle}
                    \label{serialnet_befehle}
                \end{table}

                \begin{table}
                    \begin{tabular}{lll}
                        \textbf{Ereignis} & \textbf{Beschreibung} & \textbf{Parameter}\\
                            DATA         & Daten empfangen & Adresse, Länge, Daten \\
                            EVENT:JOINED & Netzwerkverbindung hergestellt & --- \\
                            EVENT:LOST   & Netzwerkverbindung verloren & --- \\
                     \end{tabular}
                     \caption{Übersicht der \emph{SerialNet}-Ereignisse}
                     \label{serialnet_events}
                \end{table}


    \section{Kommunikation mit dem \emph{ZigBit}-Modul}\label{analyse_kommunikation_mit_zigbit_modul}
        \subsection{Problemstellung}
            Das \emph{SerialNet}-Protokoll ist grundsätzlich synchron. Ein Programm, das mit
            einem \emph{ZigBit}-Modul kommunizieren lässt sich daher am einfachsten nach folgendem
            Muster aufbauen:

            \begin{lstlisting}{Kommunikation mit dem ZigBit Modul}
def sendeBefehl(befehl)
    # Senden des Befehls
    serialPort.send(befehl)

    # Antwort vom ZigBit-Modul lesen.
    # (Blockiert so lange, bis Antwort empfangen wurde)
    statusString = serialPort.readLine()

    # Antwort interpretieren
    if statusString == 'OK':
        return True
    
    else:
        return False
            \end{lstlisting}
           
        
            Bei dieser Vorgehensweise ergeben sich jedoch zwei Probleme:
            \nomenclature{Timeout}{Fehler, der durch das Überschreiten einer Zeitgrenze aufgetreten ist.}

            \begin{enumerate}
                \item{Asynchron auftretende Ereignisse:} Die Abarbeitung eines \emph{SerialNet}-Befehls kann 
                          bis zu einer halben Minute dauern\footnote{Dies tritt insbesondere dann auf, wenn eine
                          synchrone Datenübertragung zu einem entfernten Knoten durchgeführt werden soll, der sich
                          selbst gerade im Energiesparmodus befindet. Der sendende Knoten ist hierbei so lange
                          blockiert, bis entweder der Empfang der Daten quittiert wurde oder aber ein 
                          \emph{Timeout} aufgetreten ist}. Während das Steuerungsprogramm auf die Quittierung des 
                          Befehls mit einer Status-Meldung wartet, können asynchrone Ereignisse auftreten.
                          Im oben abgebildeten Programm würde ein solches Ereignis fälschlicherweise als Antwort
                          auf den gesendeten Befehl interpretiert werden. Dies hätte zur Folge, dass nun 
                          Steuerungsprogramm und \emph{ZigBit}-Modul nicht mehr synchron zueinander ("`out-of-sync"') 
                          sind.

                \item{Komplexe Rückgabewerte:} Bestimmte Befehle der \emph{SerialNet-Firmware} liefern nicht nur
                         einen einfachen Statuscode, sondern eine komplexe, mehrzeilige Antwort zurück. 
                         Bei obigem Programm ergibt sich das Problem, dass dieses bereits nach der ersten Zeile
                         fälschlicherweise davon ausgehen würde, dass die Antwort abgeschlossen wäre, obwohl noch weitere
                         Zeilen folgen können. Auch in diesem Falle wären Steuerungsprogramm und \emph{ZigBit}-Modul nicht mehr
                         synchron zueinander.
            \end{enumerate}

        \subsection{Behandlung asynchron auftretender Ereignisse}
            \label{behandlung_asynchron_auftretender_ereignisse}

            Um asynchrone Ereignisse behandeln zu können, müssen diese zunächst erkannt werden. Dies kann mit
            Hilfe einer Liste aller möglichen Ereignisse und Statuscodes geschehen. In diesem Falle wird so lange
            von dem \emph{ZigBit}-Modul gelesen, bis ein Statuscode empfangen wurde. Zwischendurch empfangene
            Ereignisse können entweder direkt behandelt, oder zunächst in einer Liste zwischengespeichert
            werden, um sie zu einem späteren Zeitpunkt zu behandeln. Beide Verfahren haben sowohl Vor- als auch
            Nachteile:
            \nomenclature{Deadlock}{Nicht mehr zu behebende Verklemmung von mindestens zwei \emph{Threads}.}

            \begin{itemize}
                \item{Direktes Behandeln von Ereignissen:} Dieses Verfahren hat den Vorteil, dass auf empfangene 
                Ereignisse sofort reagiert werden kann; so lässt sich z.B. ein empfangener Alarm direkt
                auf dem Bildschirm darstellen und es muss nicht erst auf die Beendigung des vorherigen
                Befehls gewartet werden. Erfordert das behandelte Ereignis den Zugriff auf das 
                \emph{ZigBit}-Modul, um z.B. den Empfang einer Nachricht zu quittieren, so ist 
                besondere Vorsicht erforderlich, da sonst entweder Verklemmungen (\emph{Deadlocks}) oder
                ein Verlust der Synchronisierung auftreten können\footnote{Eine mögliche Lösung ist die
                Verwendung einer Warteschlange, in die die zu versendenden Daten eingereiht werden.}.
                Dieses Verfahren eignet sich besonders für Systeme, in denen auf eingehende Ereignisse besonders
                schnell reagiert werden muss.

                \item{Einreihen von Ereignissen in eine Warteschlange:} Diese Verfahren hat den Vorteil, dass
                es sehr einfach umgesetzt werden kann. Alle Ereignisse, die während der Bearbeitung eines Befehls
                auftreten, werden zunächst in eine Warteschlange eingereiht. Mit der Abarbeitung der Ereignisse
                wird so lange gewartet, bis der laufende Befehl abgeschlossen wurde. Während der Abarbeitung der
                Ereignisse muss dann keine Rücksicht mehr darauf genommen werden, in welchem Zustand sich das
                \emph{ZigBit}-Modul befindet, da es sich nach Abarbeitung eines Befehls sicher im betriebsbereiten
                Zustand befindet\footnote{Ausnahme hiervon ist, der zwischenzeitliche Verlust der Netzwerkverbindung,
                    der natürlich gesondert behandelt werden muss.} Nachteilig ist, dass Ereignisse
                erst behandelt werden, wenn Befehle komplett abgearbeitet wurden. Bei Ereignissen, zu deren Bearbeitung
                nicht auf das \emph{ZigBit}-Modul zugegriffen werden muss, bedeutet dies eine unnötige Verzögerung.
                Dieses Verfahren eignet sich daher eher für Systeme, in denen deutlich mehr Befehle als Ereignisse
                auftreten.
            \end{itemize}

            Durch die Verwendung von \emph{Multithreading} kann darüber hinaus eine Kombination aus beiden Verfahren
            verwenden werden. In diesem Fall wird von einem \emph{Thread} aus die Bearbeitung der Befehle, inkl. des
            Befüllens der Ereigniswarteschlange vorgenommen, während von einem anderen \emph{Thread} aus diese Warteschlange
            parallel dazu abgearbeitet wird.\\
            \\
            Das folgende Pseudocode-Programm zeigt exemplarisch das Behandeln von Ereignissen über das Einreihen in
            Warteschlangen:

            \begin{lstlisting}{Befehle in Warteschlange einreihen}
eventQueue = []

def sendeBefehl(befehl)
    # Senden des Befehls
    serialPort.send(befehl)

    # Antwort vom ZigBit-Modul lesen.
    # (Blockiert so lange, bis Antwort empfangen wurde)
    statusString = serialPort.readLine()

    # Events behandeln 
    while statusString not in ('OK', 'ERROR'):
        eventQueue.append(statusString)
        statusTring = serialPort.readLine()

    # Status Code interpretieren
    if statusString == 'OK':
        return True
    
    else:
        return False
            \end{lstlisting}

        \subsection{Behandlung von komplexen Antworten}
            \label{behandlung_von_komplexen_antworten}
            Bei der Behandlung von komplexen Antworten kommt der Umstand zur Hilfe, dass bereits
            im Voraus bekannt ist, welche Befehle eine komplexe Antwort erzeugen. Bei welchen Befehlen dies
            der Fall ist, kann aus Tabelle~\ref{serialnet_befehle} entnommen werden. Im Steuerprogramm kann beim
            Parsen des Befehls daher entsprechend Rücksicht darauf genommen werden, ob eine einzeilige oder
            eine mehrzeilige Antwort erwartet wird. Komplexe Antworten werden immer mit einem Statuscode
            beendet, d.h. wenn eine komplexe Antwort erwartet wird, muss so lange vom \emph{ZigBit}-Modul
            gelesen werden, bis ein Statuscode empfangen wird. Auch hierbei muss natürlich darauf geachtet
            werden, dass zwischen einzelnen Zeilen einer Antwort Ereignisse auftreten können, die entsprechend
            der in Abschnitt~\ref{behandlung_asynchron_auftretender_ereignisse} vorgestellten Lösung behandelt 
            werden müssen. Das folgende Pseudocode-Programm zeigt, wie komplexe Antworten behandelt werden können:

            \begin{lstlisting}{Komplexe Antworten behandeln}
def sendeBefehl(befehl)
    ## Senden des Befehls
    serialPort.send(befehl.getCmd())

    if befehl.resultIsComplex():
        ## Komplexe Antwort wird erwartet
        ## So lange lesen, bis ein Status-Code empfangen
        ## wurde
        complexResult = []
        statusString = ''

        while statusString not in ('OK', 'ERROR'):
            statusString = serialPort.readLine()
            complexResult.append(statusString)

        return statusString

    else:
        ## Antwort vom ZigBit-Modul lesen.
        ## (Blockiert so lange, bis Antwort empfangen 
        ## wurde)
        statusString = serialPort.readLine()

        ## Antwort interpretieren
        if statusString == 'OK':
            return True
        
        else:
            return False

            \end{lstlisting}

        \subsection{Kombination beider Lösungen}

        Kombiniert man die Lösungen aus Abschnitt~\ref{behandlung_asynchron_auftretender_ereignisse} und 
        Abschnitt~\ref{behandlung_von_komplexen_antworten}, ergibt sich ein weiteres Problem: Bei der
        Lösung aus Abschnitt~\ref{behandlung_asynchron_auftretender_ereignisse} wird davon ausgegangen, 
        dass alle gelesenen Zeilen, bei denen es sich nicht um Statuscodes handelt, Ereignisse sind. Diese Annahme
        ist jedoch hinfällig, sobald komplexe Antworten vom ZigBit Modul empfangen werden. Daher muss hierbei
        jede Antwort einer genaueren Prüfung unterzogen werden, ob es sich hierbei um einen Statuscode, 
        ein Event oder eine komplexe Antwort handelt. Hierbei kann eine einfache Mustererkennung verwendet
        werden.


            \begin{lstlisting}{Komplexe Antworten und Asynchrone Ereignisse behandeln}
eventQueue = []

def getResultType(input):
    if input in ('OK', 'ERROR'):
        return "Status code"
    elif input[0:4]  == 'DATA' or \
         input[0:11] == 'EVENT:JOINED' or\ 
         input[0:10] == 'EVENT:LOST':
        return "Event"
    else:
        return "Complex result"

def sendeBefehl(befehl)
    ## Senden des Befehls
    serialPort.send(befehl.getCmd())

    if befehl.resultIsComplex():
        ## Es wird eine komplexe Antwort erwartet

        ## Von seriellem Port legen
        statusString = serialPort.readLine()

        ## Komplexe Antwort wird erwartet
        ## So lange lesen, bis ein Status-Code 
        ## empfangen wurde
        complexResult = []
        
        while getResultType(statusString) != 'Status code':
            if getResultType(statusString) == 'Event':
                eventQueue.append(statusString)
            else:
                complexResult.append(statusString)

            statusString = serialPort.readLine()

        ## Ende Erreicht. Nun noch den statusCode anhaengen
        ## und Ergebnis zurueckliefern
        complexResult.append(statusString)
        return complexResult

    else:
        ## Antwort vom ZigBit-Modul lesen.
        ## (Blockiert so lange, bis Antwort
        ## empfangen wurde)
        statusString = serialPort.readLine()

        # Events behandeln 
        while statusString not in ('OK', 'ERROR'):
            eventQueue.append(statusString)
            statusTring = serialPort.readLine()

        # Status Code interpretieren
        if statusString == 'OK':
            return True
        
        else:
            return False

            \end{lstlisting}


    \section{Powermanagement}\label{analyse_powermanagement}
        Die Spannungsversorgung des Erste-Hilfe-Sensors erfolgt über Batterie. Da der Wechsel der Batterie
        während eines MANVs umständlich und zeitraubend ist, ist eine möglichst hohe Batterielaufzeit
        wünschenswert. Am besten wäre hierbei, wenn überhaupt kein Batteriewechsel notwendig wäre. Konkret
        bedeutet dies, dass mit einer Batterie eine Laufzeit von mindestens 12 Stunden erreichbar sein sollte.
        Bei einer Laufzeit von 12 Stunden ergibt sich hieraus, dass der Strombedarf des \emph{ZigBit}-Moduls
        im Mittel 20~mA nicht überschreiten darf. Im empfangsbereiten Zustand braucht das \emph{ZigBit}-Modul 
        laut Datenblatt einen Strom von 19~mA, ist also grundsätzlich zur Erfüllung dieser Anforderung
        geeignet\footnote{In dieser Betrachtung ist der Strombedarf des \emph{Erste-Hilfe-Sensors} nicht berücksichtigt.}.
        Zur Verringerung der Leistungsaufnahme bietet das \emph{ZigBit}-Modul einen Energiesparmodus,
        indem lediglich der interne Speicher gehalten und alle andere Hardware abgeschaltet wird. In
        diesem Modus braucht das Modul laut Datenblatt weniger als $6~\mu{}A$.\\
        \\
        Zum Stromsparen wird das Modul periodisch für eine bestimmte Zeit in den
        Energiesparmodus versetzt. Während dieser Zeit kann das Modul weder von der Steurungssoftware angesprochen
        werden, noch können Daten vom Netzwerk empfangen werden. Damit in dieser Zeit keine Informationen
        verloren gehen, werden vom nächstgelegenen Router alle Nachrichten an dieses Modul zwischengespeichert,
        bis dieses wieder im empfangsbereiten Zustand ist. Bei Verwendung der \emph{SerialNet-Firmware} wird
        die Dauer des Verweilens im Energiesparmodus über den Befehl \emph{AT+WPWR} konfiguriert. Die Konfiguration
        erfolgt in Schritten zu 100~ms.\\
        \\
        Zum Aufruf des Energiesparmodus bieten sich nun zwei Möglichkeiten:

        \begin{itemize}
            \item{Automatsisches Aufrufen des Energiesparmodus:} Hierbei wird über den zweiten Paramter
            des Befehls \emph{AT+WPWR} ein Intervall angegeben, in dem der Energiesparmodus periodisch
            aufgerufen wird. Hierbei erfolgt die Eingabe in Schritten von 10ms.

            \item{Manuelles Aufrufen des Energiesparmodus:} Alternativ zum automatischen Aufrufen kann
            der Energiesparmodus über den Befehl \emph{AT+WSLEEP} auch manuell aufgerufen werden. Dies
            kann entweder entweder alternativ zum automatischen Aufrufen oder als Ergänzung verwendet
            werden.

        \end{itemize}

        Bei der Verwendung des Energiesparmodus muss sichergestellt werden, dass keine Informationen,
        die über die \emph{UART}-Schnittstelle an das Modul gesendet werden, verloren gehen. Hierzu 
        bietet die \emph{SerialNet-Firmware} die Möglichkeit, über die \emph{CTS}-Leitung der 
        \emph{UART}-Schnittstelle ihre Empfangsbereitschaft zu signalisieren. Die Steurungssoftware
        auf der Gegenseite muss hierzu vor jedem Senden den Zustand der \emph{CTS}-Leitung
        kontrollieren, und darf nur senden, wenn die \emph{CTS}-Leitung den Zustand 0 hat. Damit die
        \emph{SerialNet-Firmware} diesen Zustand korrekt kommuniziert, muss über den Befehl \emph{AT+IFC}
        die Flusskontrolle aktiviert werden. \\
        \\
        Zu beachten ist, dass die Konfiguration des Energiesparmodus bei allen Teilnehmern des Netzes
        (also auch auf \emph{Routern} und \emph{Coordinatoren}) gleich sein sollte, damit Nachrichten
        an Knoten, die sich im Energiesparmodus befinden, auf den Routern lange genug zwischengespeichert werden.
        Der eigentliche Energiesparmodus steht allerdings nur auf Endknoten, also \emph{RFD}s zur Verfügung.
