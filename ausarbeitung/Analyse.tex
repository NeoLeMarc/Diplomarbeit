\chapter{Analyse}
    \section{Anforderungen an ein kabelloses System zur Überwachung von Patienten}
    Austauschbarkeit beachten!

    \section{Kommunikation mit dem \emph{ZigBit}-Modul}\label{analyse_kommunikation_mit_zigbit_modul}
        \subsection{Problemstellung}
            Das \emph{SerialNet} Protokoll ist grundsätzlich synchron. Ein Programm, dass mit
            einem \emph{ZigBit}-Modul kommuniziert lässt sich daher am einfachsten nach folgendem
            Muster aufbauen:

            \begin{lstlisting}{frame=analyse1}
def sendeBefehl(befehl)
    # Senden des Befehls
    serialPort.send(befehl)

    # Antwort vom ZigBit-Modul lesen.
    # (Blockiert so lange, bis Antwort empfangen wurde)
    statusString = serialPort.readLine()

    # Antwort interpretieren
    if statusString == 'OK':
        return True
    
    else:
        return False
            \end{lstlisting}
           
        
            Bei dieser Vorgehensweise ergeben sich jedoch zwei Probleme:

            \begin{enumerate}
                \item{Asynchron auftretende Ereignisse:} Die Abarbeitung eines \emph{SerialNet}-Befehls kann 
                          bis zu einer halben Minute dauern\footnote{Dies tritt insbesondere dann auf, wenn eine
                          synchrone Datenübertragung zu einem entfernten Knoten durchgeführt werden soll, der sich
                          selbst gerade im Energiesparmodus befindet. Der sendende Knoten ist hierbei so lange
                          blockiert, bis entweder der Empfang der Daten quittiert wurde, oder aber ein 
                          Timeout aufgetreten ist}. Während das Steuerungprogramm auf die Quittierung des 
                          Befehls mit einer Status-Meldung wartet, können asynchrone Ereignisse auftreten.
                          Im oben abgebildeten Programm würde dieses Ereigniss fälschlicherweise als Antwort
                          auf den gesendeten Befehl interpretiert werden. Dies hätte zur Folge, dass nun 
                          Steurungsprogramm und \emph{ZigBit}-Modul nicht mehr synchron zueinander ("`out-of-sync"') 
                          sind.

                \item{Komplexe Rückgabewerte:} Bestimmte Befehle der \emph{SerialNet}-Firmware liefern nicht nur
                         einen einfachen Statuscode sondern eine komplexe, Mehrzeilige Antwort zurück. Auch hier ergibt
                         sich bei obigem Programm wieder das Problem, dass dieses bereits nach der ersten Zeile
                         fälschlicherweise davon ausgehen würde, dass die Antwort abgeschlossen wäre, obwohl noch weitere
                         Zeilen folgen können. Auch in diesem Falle wären Steurungsprogramm und \emph{ZigBit}-Modul nichtmehr
                         synchron zueinander.
            \end{enumerate}

        \subsection{Behandlung asynchron auftretender Ereignisse}
            \label{behandlung_asynchron_auftretender_ereignisse}

            Um asynchrone Ereignisse behandeln zu können, müssen diese zunächst erkannt werden. Dies kann mit
            Hilfe einer Liste aller Ereignisse und Statuscodes geschehen. In diesem Falle wird so lange
            von dem \emph{ZigBit}-Modul gelesen, bis ein Statuscode empfangen wurde. Zwischendurch empfangene
            Ereignisse können entweder direkt behandelt werden, oder zunächst in einer Liste zwischengespeichert
            werden, um sie zu einem späteren Zeitpunkt zu behandeln. Beide Verfahren haben sowohl Vor- als auch
            Nachteile:

            \begin{itemize}
                \item{Direktes Behandeln von Events:} Dieses Verfahren hat den Vorteil, dass auf empfangene 
                Ereignisse sofort reagiert werden kann; so lässt sich z.B. ein empfangener Alarm direkt
                auf dem Bildschirm darstellen und es muss nicht erst auf die Beendigung des vorherigen
                Befehls gewartet werden. Erfordert das behandelte Event den Zugriff auf das 
                \emph{ZigBit}-Modul um z.B. den Empfang einer Nachricht zu quittieren, so ist eine
                besondere Vorsicht erforderlich, da sonst entweder Verklemmungen ("'Deadlock"`) oder
                ein Verlust der Synchronisierung auftreten kann\footnote{Eine mögliche Lösung ist die
                Verwendung einer Warteschlange, in die die zu versendenden Daten eingereiht werden.}.
                Dieses Verfahren eignet sich besonders für Systeme, in denen auf eingehende Ereignisse besonders
                schnell reagiert werden muss.

                \item{Einreihen von Ereignisse in eine Warteschlange:} Diese Verfahren hat den Vorteil, dass
                es sehr einfach umgesetzt werden kann. Alle Ereignisse, die während der Bearbeitung eines Befehls
                auftreten werden zunächst in eine Warteschlange eingereiht. Mit der Abarbeitung der Ereignisse
                wird so lange gewartet, bis der laufende Befehl abgeschlossen wurde. Während der Abarbeitung der
                Ereignisse muss dann keine Rücksicht mehr darauf genommen werden, in welchem Zustand sich das
                \emph{ZigBit}-Modul befindet, da es sich nach Abarbeitung des Befehls sicher im Betriebsbereiten
                Zustand befindet\footnote{Ausnahme hiervon ist, wenn zwischenzeitlich die Netzwerkverbindung verloren
                gegangen ist, was natürlich gesondert behandelt werden muss.}. Nachteilig ist, dass Ereignisse
                erst behandelt werden, wenn Befehle komplett abgearbeitet wurden. Bei Ereignissen, zu deren Bearbeitung
                nicht auf das \emph{ZigBit}-Modul zugegriffen werden muss bedeutet dies eine unnötige Verzögerung.
                Dieses Verfahren eignet sich daher eher für Systeme, in denen deutlich mehr Befehle als Ereignisse
                auftreten.
            \end{itemize}

            Durch die Verwendung von Multithreading kann darüber hinaus eine Kombination aus beiden Verfahren
            verwenden werden. In diesem Fall wird von einem Thread aus die Bearbeitung der Befehle, inkl. des
            Befüllens der Ereigniswareteschlange vorgenommen, während von einem anderen Thread aus diese Warteschlange
            parallel dazu abgearbeitet wird.\\
            \\
            Das folgende Pseudocode-Programm zeigt exemplarisch das Behandeln von Events über das Einreihen in
            Warteschlangen:

            \begin{lstlisting}{frame=analyse2}
eventQueue = []

def sendeBefehl(befehl)
    # Senden des Befehls
    serialPort.send(befehl)

    # Antwort vom ZigBit-Modul lesen.
    # (Blockiert so lange, bis Antwort empfangen wurde)
    statusString = serialPort.readLine()

    # Events behandeln 
    while statusString not in ('OK', 'ERROR'):
        eventQueue.append(statusString)
        statusTring = serialPort.readLine()

    # Status Code interpretieren
    if statusString == 'OK':
        return True
    
    else:
        return False
            \end{lstlisting}

        \subsection{Behandlung von komplexen Antworten}
            \label{behandlung_von_komplexen_antworten}
            Bei der Behandlung von komplexen Antworten kommt der Umstand zur Hilfe, dass bereits
            im Vorraus bekannt ist, welche Befehle eine komplexe Antwort erzeugen. Bei welchen Befehlen dies
            der Fall ist kann aus Tabelle~\ref{zigbit_befehle} entnommen werden. Im Steuerprogramm kann beim
            Parsen des Befehls daher entsprechend Rücksicht darauf genommen werden, ob eine einzeilige oder
            eine mehrzeilige Antwort erwartet wird. Komplexe Antworten werden immer mit einem Statuscode
            beendet, d.h. wenn eine komplexe Antwort erwartet wird, muss so lange vom \emph{ZigBit}-Modul
            gelesen werden, biss ein Statuscode empfangen wird. Auch hierbei muss natürlich darauf geachtet
            werden, dass zwischen einzelnen Zeilen einer Antwort Ereignisse auftreten können, die entsprechend
            der in Abschnitt~\ref{behandlung_asynchron_auftretender_ereignisse} vorgestellten Lösung behandelt 
            werden müssen.

            \begin{lstlisting}{frame=analyse3}
def sendeBefehl(befehl)
    ## Senden des Befehls
    serialPort.send(befehl.getCmd())

    if befehl.resultIsComplex():
        ## Komplexe Antwort wird erwartet
        ## So lange lesen, bis ein Status-Code empfangen wurde
        complexResult = []
        statusString = ''

        while statusString not in ('OK', 'ERROR'):
            statusString = serialPort.readLine()
            complexResult.append(statusString)

        return statusString

    else:
        ## Antwort vom ZigBit-Modul lesen.
        ## (Blockiert so lange, bis Antwort empfangen wurde)
        statusString = serialPort.readLine()

        ## Antwort interpretieren
        if statusString == 'OK':
            return True
        
        else:
            return False

            \end{lstlisting}

        \subsection{Kombination beider Lösungen}

        Kombiniert man die Lösungen aus Abschnitt~\ref{behandlung_asynchron_auftretender_ereignisse} und 
        Abschnitt~\ref{behandlung_von_komplexen_antworten} ergibt sich ein weiteres Problem: Bei der
        Lösung aus Abschnitt~\ref{behandlung_asynchron_auftretender_ereignisse} wird davon ausgegangen, 
        dass alle Ergebnisse, bei denen es sich nicht um Statuscodes handelt, Ereignisse sind. Diese Annahme
        ist jedoch hinfällig, sobald komplexe Antworten vom ZigBit Modul empfangen werden. Daher muss hierbei
        jede Antwort einer genaueren Prüfung unternommen werden, ob es sich hierbei um einen Status Code, 
        ein Event oder eine Komplexe Antwort handelt. Hierbei kann eine einfache Mustererkennung verwendet
        werden.


            \begin{lstlisting}{frame=analyse4}
eventQueue = []

def getResultType(input):
    if input in ('OK', 'ERROR'):
        return "Status code"
    elif input[0:4]  == 'DATA' or \
         input[0:11] == 'EVENT:JOINED' or\ 
         input[0:10] == 'EVENT:LOST':
        return "Event"
    else:
        return "Complex result"

def sendeBefehl(befehl)
    ## Senden des Befehls
    serialPort.send(befehl.getCmd())

    if befehl.resultIsComplex():
        ## Es wird eine komplexe Antwort erwartet

        ## Von seriellem Port legen
        statusString = serialPort.readLine()

        ## Komplexe Antwort wird erwartet
        ## So lange lesen, bis ein Status-Code empfangen wurde
        complexResult = []
        
        while getResultType(statusString) != 'Status code':
            if getResultType(statusString) == 'Event':
                eventQueue.append(statusString)
            else:
                complexResult.append(statusString)

            statusString = serialPort.readLine()

        ## Ende Erreicht. Nun noch den statusCode anhaengen und
        ## Ergebnis zurueckliefern
        complexResult.append(statusString)
        return complexResult

    else:
        ## Antwort vom ZigBit-Modul lesen.
        ## (Blockiert so lange, bis Antwort empfangen wurde)
        statusString = serialPort.readLine()

        # Events behandeln 
        while statusString not in ('OK', 'ERROR'):
            eventQueue.append(statusString)
            statusTring = serialPort.readLine()

        # Status Code interpretieren
        if statusString == 'OK':
            return True
        
        else:
            return False

            \end{lstlisting}


    \section{Powermanagement}\label{analyse_powermanagement}
        Die Spannungsversorgung des Erste-Hilfe-Sensors erfolgt über Batterie. Da der Wechsel der Batterie
        während eines MANVs umständlich und zeitraubend ist, ist eine möglichst hohe Batterielaufzeit
        wünschenswert. Am besten wäre hierbei, wenn überhaupt kein Batteriewechsel notwendig wäre. Im
        empfansbereiten Zustand braucht das \emph{ZigBit}-Modul laut Datenblatt einen Strom von 19mA.
        Zur Verringerung der Leistungsaufnahme bietet das \emph{ZigBit}-Modul einen Energiesparmodus,
        indem lediglich der interne Speicher gehalten und alle andere Hardware abgeschaltet wird. In
        diesem Modus braucht das Modul laut Datenblatt weniger als $6\mu{}A$.\\
        \\
        Zum Stromsparen wird das Modul periodisch für eine bestimmte Zeit in den
        Energiesparmodus versetzt. Während dieser Zeit kann das Modul weder von der Steurungssoftware angesprochen
        werden, noch können Daten vom Netzwerk empfangen werden. Damit in dieser Zeit keine Informationen
        verloren gehen, werden vom nächstgelegenen Router alle Nachrichten an dieses Modul zwischengespeichert,
        bis dieses wieder im Empfangsbereiten Zustand ist. Bei Verwendung der \emph{SerialNet}-Firmware wird
        die Dauer des Verweilens im Energiesparmodus über den Befehl \emph{AT+WPWR} konfiguriert. Die Konfiguration
        erfolgt in Schritten zu 100ms.\\
        \\
        Zum Aufruf des Energiesparmodus bieten sich nun zwei Möglichkeiten:

        \begin{itemize}
            \item{Automatsisches Aufrufen des Energiesparmodus:} Hierbei wird über den zweiten Paramter
            des Befehls \emph{AT+WPWR} ein Intervall angegeben, in dem der Energiesparmodus periodisch
            aufgerufen wird. Hierbei erfolgt die Eingabe in Schritten von 10ms.

            \item{Manuelles Aufrufen des Energiesparmodus:} Alternativ zum automatischen Aufrufen kann
            der Energiesparmodus über den Befehl \emph{AT+WSLEEP} auch manuell aufgerufen werden. Dies
            kann entweder entweder Alternativ zum automatischen Aufrufen oder als Ergänzung verwendet
            werden.

        \end{itemize}

        Bei der Verwendung des Energiesparmoduses muss sichergestellt werden, dass keine Informationen,
        die über die \emph{UART}-Schnittstelle an das Modul gesendet werden, verloren gehen. Hierzu 
        bietet die \emph{SerialNet}-Firmware die Möglichkeit, über die \emph{CTS}-Leitung der 
        \emph{UART}-Schnittstelle ihre Empfangsbereitschaft zu signalisieren. Die Steurungssoftware
        auf der Gegenseite muss hierzu vor jedem Senden den Zustand der \emph{CTS}-Leitung
        kontrollieren, und darf nur senden, wenn der Zustand den Wert 0 hat. Damit die
        \emph{SerialNet}-Firmware diesen Zustand korrekt kommuniziert, muss über den Befehl \emph{AT+IFC}
        die Flußkontrolle aktiviert werden. \\
        \\
        Zu beachten ist, dass die Konfiguration des Energiesparmodueses bei allen Teilnehmern des Netzes
        (also auch auf Routern und Coordinator) gleich sein sollte. Der eigentliche Energeisparmodus steht
        allerdings nur auf Endknoten, also \emph{RFD}s zur Verfügung.
