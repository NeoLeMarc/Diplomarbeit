

%%%------------------------------------------------Entwurf -------------------------------------------------------------
\chapter{Entwurf}

\section{Gesamtsystem}
\Abbildungps{!htb}{1}{diagramme/Gesamtuebersicht.pdf}{label}{Überblick über das Gesamtsystem}

\section{Hardware}
\subsection{MANVNode}
\subsubsection{Beschreibung}
\Abbildungps{!htb}{1.25}{diagramme/platine_manvnode-crop.pdf}{label}{Entwurf der Platine der MANVNode}
Die MANVNode ist eine Test- und Entwicklungsplatine zum Test der Sensornetzes. Auf ihr befindet sich ein 
ADuC-7026-Mikrocontroller der Firma Analog Devices sowie ein Atmel ZigBit-Funkmodul des Typs ATZB-24-A2. Die Platine 
dient zur Simulation des Erste-Hilfe-Sensors. An Stelle einer echten Messung generiert die Platine Messwerte mit Hilfe 
eines Zufallszahlen-Generators.
Dier Generator kann in drei Zuständen beschrieben werden:

\begin{itemize}
    \item{Grün:} Simulation eines Patienten mit gutem Kreislaufzustand. Puls zwischen 60 und 120 Schlägen pro Minute, 
                 Atemzüge pro Minute zwischen 12 und 15. Periodischer Versand der Meldung "`Zustand OK"'.
    \item{Gelb:} Simulation eines Patienten mit beginnend kritischem aber noch nicht akut Lebensbedrohlichem 
                 Kreislaufzustand. Puls zwischen 120 und 180 Schlägen pro Minute, Atmung zwischen 60 und 80
                 Zügen pro Minute (Hyperventilation).
    \item{Rot:}  Simulation eines Patienten in kritischem Zustand mit Puls zwischen 0 und 10 (entsprechend
                 Kammerflimmern oder Kreislaufstillstand) sowie Atmung zwischen (0 und 2) mit bestehndem
                 akutem Handlungsbedarf. Priorisierte Generierung eienr Alarmmeldung.
\end{itemize}

Zur Einstellung und Wechsel der Zustände befinden sich 3 Schalter an der Platine. Der Zustand wird mit Hilfe von
drei farbigen LEDs visualisiert. Zusätzlich kann über einen Piezzo-Summer ein Alarm auch akustisch wiedergegeben werden.
Durch die Kombination der drei LEDs werden zusätzlich Status- und Fehlerinformationen der Platine während des 
Initialisierungsvorgangs ausgegeben.

\subsection{Spannungsversorgung}
Um die Platine möglichst vielseitig einzusetzen wurde wert auf eine möglichst flexible Spannungsversorgung gelegt. Diese
soll möglichst Robust gegenüber Spannungsschwankungen sein. Kern der Spannungsversorgung ist ein 
Low-Dropout-Spannungsregler des Typs LP2980-3.3 der Firma National Semiconductor. Dieser liefert eine stabile
3,3V Spannung bei einem maximalen Strom von 50mA. Die Eingangsspannung kann zwischen 2.1V bis 16V variiert werden.
Die Spannungsversorgung kann damit z.B. über USB (5V-Versorgungsspannung), ein externes Netzteil oder eine 
9V-Blockbatterie gespeist werden. Durch die hohe maximale Versorgungsspannung von 9V sind Schäden durch versehentliches
anschließen eines falschen Netzteils weitestgehend ausgeschlossen. Die Spannungsversorgung ist zusätzlich mit einem 10mF 
Kondensator stabilisiert.

Zusätzlich wurde die die Spannungsversorgung weiter stabilisiert. Hierzu wurde jeder Spannungseingang aller Bauteile der
Platine mit einem 100nF Kondensator gepuffert. Diese sind möglichst nahe an den entsprechenden Versorgungspins angebracht.
Kurzzeitige Spannungsabfälle, wie sie z.B. beim Schalten von LEDs, des Piezzo-Summers oder des Aufwachsens des ZigBee-Moduls
aus dem Stromsparmodus auftreten können, werden so zuverlässig abgefangen.

\subsection{Programmierschnittstellen}

\subsubsection{Serielle Schnittstellen}
Die \emph{MANVNode}-Platine verfügt über mehrere seriellen Schnittstellen. Im äußeren Bereich der Platine ist eine serielle 
Schnittstelle (JP1) vorhanden, welche der Standardbelegung des Programmierkabels des ADuC-7026-Evaluationsboards besitzt.
Bereits vorhandene Programmierkabel können somit ohne weiteres zur Programmierung des Mikrocontrollers verwendet werden.
Zusätzlich besthet die Möglichkeit, auf die serielle Schnittstelle des ZigBit-Moduls zuzugreifen, worüber das Herunterladen 
von Firmware auf das Modul, sowie der Einstellung bestimmter Parameter wie der Netzwerkkennung des Gerätes möglich ist.
Der Zugriff erfolgt ebenfalls über die Stiftleiste JP1, allerdings muss hierfür RX- und TX-Leitung des Programmierkabels 
verdreht, und alle Jumper des Schalters S1 unterbrochen werden. 

\subsubsection{JTAG}
Die \emph{MANVNode}-Platine verfügt neben seriellen auch über eine JTAG-Schnittstelle. Diese ermöglich einen Zugriff mit
gängigen Programmierwerkzeugen wie z.B. Eclipse, Crossworks oder Kyle $\mu{}$Vision. Über die Schnittstelle kann sowohl 
Programmierung als auch Debugging des ADuC-7026-Mikrocontrollers durchgeführt werden. Ein Zugriff auf das ZigBit
Modul ist allerdings nur indirekt möglich\footnote{Einige Werkzeuge bieten die Möglichkeit, eine Consolenverbindung
über den UART des ADuC-7026-Mikrocontrollers zu öffnen, so direkt mit dem ZigBit-Modul kommunikation möglich ist.}.
Ein Zugriff über JTAG ist nicht vorgesehen.

\subsection{LEDs}

\subsubsection{Beschreibung der einzelnen LEDs}
Die \emph{MANVNode}-Platine verfügt insgesamt über 6 LEDs, die zur Anzeige des aktuellen Zustands sowie zur Fehlerdiagnose dienen.
\begin{itemize}
    \item{PWR:} Diese LED befindet sich direkt in der Spannungsversorgung der Platine. Diese LED leuchtet, sobald
                die Platine mit Spannung versorgt wird. 
    \item{GREEN, YELLOW, RED}: Diese LEDs sind direkt an den Mikrocontroller angeschlossen und visualisieren den Zustand des
                               Zufallszahlengenrators entweder durch dauerhaftes Leuchten (GREEN, YELLOW) oder im Alarmzustand
                               durch schnelles Blinken (RED). 
    \item{BLUE}: Diese LED signalisiert, ob eine Alarmunterdrückung ("`Mute"') besteht.
    \item{ZIGBIT-STATUS}: Diese LED leuchtet, sobald das ZigBit-Modul über das CTS-Signal ("`Clear to send"') die Bereitschaft, 
                          Daten zu empfangen, signalisiert.
\end{itemize}
                 
    

\subsubsection{Diagnosecodes}
Neben den oben dargestellten einfachen Signalisierungen hat die Firmware der \emph{MANVNode}-Platine die Möglichkeit, über die
Kombination obiger LEDs Diagnose und Fehlercodes auszugeben. Hierbei gilt folgende Codierung:

\begin{itemize}
    \item{Led GREEN blinkt in 1-Sekunden-Perioden:} Der ADuC-7026-Mikrocontroller befindet sich im Bootmodus. Ein Reset des
                                                    ZigBit-Moduls wurde durchgeführt und es wird nun auf Bereitschaft des Moduls
                                                    gewartet.
    \item{Zweimaliges Blinken von YELLOW:} Eine Verbindung mit dem ZigBit-Modul wurde erfolgreich aufgebaut, es wird nun eine 
                                           Initialisierung vorgenommen.
    \item{RED, GREEN leuchten gleichzeitig:} Das ZigBit-Modul wurde erfolgreich initalisiert, auf die Verbindung mit dem 
                                                Funknetzwerk wird gewartet.
    \item{YELLOW leuchtet dauerhaft länger als 10 Sekunden und
          ZIGBIT-STATUS leuchtet dauerhaft:} Es kann keine Verbindung mit dem Funktnetzwerk aufgebaut werden.
    \item{YELLOW leuchtet dauerhaft länger als 10 Sekunden und ZIGBIT-STATUS leuchte nicht:} Es liegt eine Funktionsstörung des
          ZigBit-Moduls vor.
    \item{ZIGBIT-STATUS leuchtet dauerhaft:} Verbindung mit Funknetzwerk wurde verloren oder Powersafe-Modus ist deaktiviert.
    \item{ZIGBIT-STATUS blinkt im 2 Sekunden Interval:} Die Platine arbeitet Ordnungsgemäß, es besteht eine Verbindung mit dem
                                                        Funknetzwerk und der Powersafe-Modus ist aktiv.
\end{itemize}
                                                        
\subsubsection{\emph{MANV-USB-Connector}}
\Abbildungps{!htb}{0.25}{diagramme/Ansteuerung-USB-Stick.pdf}{label}{Datenfluss zwischen Server und Netzwerk}
\Abbildungps{!htb}{0.4}{diagramme/platine_usbstick-crop.pdf}{label}{Platine des USB-Sticks}

Der \emph{MANV-USB-Connector} ist die Schnittstelle zwischen Sensornetz und Computer. Es handelt sich um einen USB-Stick, der einen
ZigBit-Modul beinhaltet. Zusätzlich sind zwei weitere Bauteile enthalten, die das ZigBit-Modul mit Strom versorgen, sowie eine
Umsetzung der UART-Schnittstelle des ZigBit-Moduls auf USB vornehmen. Für die Stromversorgung ist es notwendig, die 5V der
USB-Schnittstelle auf die 3V des ZigBit-Moduls umzusetzen.

\section{Software}
\subsection{MANVNode Firmware}

\subsubsection{Funktionalität}
Die Firmware der \emph{MANVNode} dient dem Entwickeln und Testen eines Treibers für das \emph{ZigBit}-Modul. Dieser
Treiber wird später in den Erste-Hilfe-Sensor integriert werden. Zusätzlich bietet die \emph{MANVNode} Funktionalität,
die zur Simulation des Erste-Hilfe-Sensors gegenüber der \emph{MANVSuite} dient. Hierzu sollen neben dem 
\emph{ZigBit}-Treiber folgende Funktionalitäten integriert werden:

\begin{itemize}
    \item Zufallszahlengenerator zum Senden zufälliger Messwerte
    \item Änderung des Zustands des Zufallszahlengenerators über Tasterkj
    \item Ansteuerung von LEDs zur Ausgabe des Zustands des Zufallszahlengenerators
    \item Ansteuerung eines Piezzo-Summers zur Signalisierung von Alarmen
\end{itemize}


\subsubsection{Ansteuerung des ZigBit-Moduls}
Das \emph{ZigBit}-Modul ist via \emph{UART} mit der \emph{MANVNode} verbunden und wird über das \emph{SerialNet}-Protokoll
angesprochen.

\subsubsection{Ansteuerung des UARTs}
Zur Vermeidung von \emph{Busy-Waiting} soll der Treiber für den \emph{UART}s als Interrupt-Service-Routine (ISR)
realisiert werden. Die Kommunikation zwischen Firmware und \emph{UART}-Treiber soll über Ringpuffer erfolgen:
Zu sendende Daten werden von der Firmware in den Sendepuffer gelegt. Sobald der \emph{UART} sendebereit ist, 
soll der \emph{UART}-Treiber die zu sendenden Daten Zeilenweise aus dem Ringpuffer entnehmen und an
den \emph{UART} übertragen. Analog dazu ist das Empfangen von Daten: Diese werden vom \emph{UART}-Treiber gelesen,
und zeilenweise in den Empfangspuffer gelegt. Die Firmware kann diese nun zeilenweise aus dem Puffer lesen.
Dies entspricht der Semantik einer gepufferten, nicht blockierenden Ein-/Ausgabefunktion.
% Hier Tannenbaum zitieren

\subsubsection{Ansteuerung des ZigBit-Modul}
Die Ansteuerung des \emph{ZigBit}-Moduls soll in folgenden Schritten erfolgen: 

\begin{lstlisting}{frame=entwurfZigBit1}
Uebertragen aktuellen Status
Werte Antwort aus
Arbeite empfangene Befehle ab
Aktiviere den Energiesparmodus
\end{lstlisting}

Diese Schritte können entweder periodisch mittles eines Timer-Interrupts oder als Hauptprogramm in einer Endlosschleife
ausgeführt werden. Wichtig hierbei ist die Berücksichtigung der in Abschnitt~\ref{kommunikation_mit_zigbit_modul}
beschriebenen Synchronisationsprobleme. Hierbei soll wie folgt vorgegangen werden:

\begin{itemize}
    \item{Behandlung asynchron auftretender Ereignisse:} Hierbei ist vor allem das \emph{DATA}-Ereignis wichtig, über das
    der Empfang von Befehlen von der \emph{MANVSuite} signalisiert wird. Alle anderen Events können zunächst vernachlässigt
    werden. Ereignisse, die während des Wartens auf einen Statuscode auftreten, sollen zur späteren Behandlung in einen
    Ringpuffer zwischengespeichert werden. Die Abarbeitung soll dann nach Empfang des Statuscodes erfolgen.

    \item{Behandlung komplexer Rückgabewerte:} Im aktuellen Entwurf werden von der Firmware der \emph{MANVNode} keine 
    \emph{SerialNet}-Befehle verwendet, die eine komplexe Rückgabe haben, so dass dieses Problem eigentlich auftreten 
    sollte. Sollten trotzdem komplexe Rückgaben auftreten, so werden diese wie asynchron auftretende Ereignisse behandelt
    und in den Befehlspuffer gelegt. Bei der späteren Auswertung des Befehlspuffers werden diese dann einfach verworfen.
    So bleibt eine Synchronisation mit dem \emph{ZigBit}-Modul in jedem Fall gewährleistet.
\end{itemize}

Die \emph{SerialNet}-Firmware bietet die Möglichkeit, den Energiesparmodus entweder manuell oder aber in einer 
konfigurierbaren Periode automatisch aufzurufen (Vgl. Abschnitt~\ref{analyse_powermanagement}). Für die
\emph{MANVNode}-Firmware soll der manuelle Aufruf verwendet werden, da dieser deutlich flexibler und einfacher zu
implementieren ist als der automatische Modus: Sobald die Übertragung der Zustandsdaten abgeschlossen ist, und
alle empfangenen Befehle abgearbeitet wurden, soll die Firmware über den Befehl \emph{AT+WSLEEP} den Energiesparmodus
aufrufen. Hierdurch ist gewährleistet, dass das \emph{ZigBit}-Modul nur so lange wie zur Bearbeitung aller Aufgaben
notwendig in Betrieb ist. Nachdem das \emph{ZigBit}-Modul aus dem Energiesparmodus zurückkehrt wird die Abarbeitung
der Ansteuerungsroutine von vorne begonnen. Das Aufwachen aus dem Energiesparmodus wird der \emph{MANVNode}-Firmware
über eine Zustandsänderung des \emph{CTS}-Registers des \emph{UART} signalisiert. Zusätzlich wird der \emph{AT+WSLEEP}
Befehl mit dem Statuscode \emph{OK} quittiert, sobald das \emph{ZigBit}-Modul wieder betriebsbereit ist. 


Insgesamt ergibt sich für die Ansteuerung des ZigBit Moduls folgender Ablauf:

\begin{lstlisting}{frame=entwurfZigBit2}
Uebertrage aktuellen Status
Wiederhole:
    Antwort von ZigBit-Modul lesen
    Falls Antwort != Statusnachricht:
        Antwort in Befehlspuffer legen
bis Antwort == Statusnachricht    
Arbeite Befehlspuffer ab
Aktiviere den Energiesparmodus
\end{lstlisting}

Dieser Ablauf ist in Abbildung~\ref{zigbit_mainloop} als Ablaufdiagramm dargestellt.
\Abbildungps{!htb}{0.5}{diagramme/Flussdiagramm-Firmware-Mainloop.pdf}{zigbit_mainloop}{Ablauf der Ansteuerung des \emph{ZigBit}-Moduls.}

\subsection{MANVSuite}

In dieser Arbeit wurde ein Java-Treiber (MANVConnector) entworfen und implemtiert. Dieser Treiber realisiert die die 
Anbindung an die von Herrn Tepelmann in \cite{Jan} entwickelte MANVSuite. 


\subsection{MANVConnector}
\Abbildungps{!htb}{1.25}{diagramme/manv_connector_sequenzdiagramm_main.pdf}{sequenzdiagramm_manvconnector}{Interaktion der einzelnen Threads des \emphf{MANVConnectors}}


Der \emph{MANVConnector} hat einerseits die Aufgabe, Daten die von dem \emph{MANV-USB-Connector} empfangen wurden in Corba-Events 
umzusetzen, und an den \emph{MANVServer} weiterzuleiten. Andererseits empfängt sie Corba-Events vom \emph{MANVServer}, dekodiert
diese und sendet diese in Form von Sensornetz Befehlen an die zuständigen \emph{MANVNodes} weiter.

Bei der Kommunikation mit dem auf dem USB-Stick aufgebrachten ZigBee-Modul stellen sich grundsätzlich die selben 
Synchronisierungsprobleme wie in der \emph{MANVFirmware}. Da der \emph{MANVConnector} jedoch alle Möglichkeiten der Java-Virtual-Machine
nutzen kann, lassen sich diese deutlich einfacher und eleganter lösen. 

In der MANVFirmware werden hierzu mehrere Ringpuffer verwendet, welche die empfangenen Daten speichern. Diese finden sich auch
im MANVConnector wieder. Hierbei werden an Stelle von Ringpuffern priorisierte Warteschlangen, sogenannte Queues verwendet. 

\begin{itemize}
    \item{Die Command Queue:} In dieser Queue werden alle zu sendenden Befehle gespeichert.
    \item{Die Event Queue:} In dieser Queue werden alle empfangenen Ereignisse gespeichert.
    \item{Die Result Queue:} In dieser Queue werden alle bereits gesendeten Befehle zusammen mit dem
                             Resultat, das dieser Befehl hatte, gespeichert.
\end{itemize}

Jedes Element der einzelnen Queues verfügt über eine Priorität; die Queues sorgen dafür, dass der
Zugriff nach Priotität sortiert erfolgt. Hierdurch wird sicher gestellt, dass wichtige Ereignisse
wie z.B. ein Alarm bevorzugt ausgeliefert werden.

Der MANVConnector verfügt neben dem Hauptthread über drei weitere Threads:

\begin{itemize}
    \item{SocketWriter:} Dieser Thread entnimmt Befehle aus der \textsl{CommandQueue} und sendet
                         diese über den MANV-USB-Connector an das Sensornetz. Nun blockiert der
                         Thread so lange, bis das Ergebnis des Befehls zur Verfügung steht.
                         Sobald dies der Fall ist, wird der Befehl zusammen mit dem Ergebnis in
                         die \textsl{ResultQueue} eingefügt.
    \item{SocketReader:} Dieser Thread empfängt Daten aus dem Sensornetz. Handelt es sich um ein
                         Ergebnis, so wird dies dem \textsl{SocketWrite} signalisiert, und das
                         Ergebnis zur Abholung durch den \textsl{SocketWriter} zur Verfügung
                         gestellt. Handelt es sich hingegen um einen Ereignis, so wird dieses
                         in die \textsl{EventQueue} eingefügt.
    \item{CorbaSender:} Dieser Thread ist für die Kommunikation mit MANVServer zuständig.
                         Befehle, die vom MANVServer empfangen werden, werden für das 
                         Sensornetz aufbereitet und in die CommandQueue eingestellt.
                         Ausserdem werden Ereignisse aus der \textsl{EventQueue} entnommen,
                         in Corba-Events übersetzt und an den MANVServer zugestellt.
\end{itemize}                          

Die Kommunikation der Threads untereinander findet komplett über die oben genannten Warteschlangen statt. Das Zusammenwirken der Threads
ist in Abbildung~\ref{sequenzdiagramm_manvconnector} dargestellt:\\

Zunächst erzeugt der Hauptthread (\emph{MANVConnector.main}) die drei Warteschlangen. Dannach werden die beiden Threads
\emph{SocketWriter} und \emph{SocketReader} erstellt. Dannach ruft der Hauptthread die Corba-Inizialisierungsroutine auf und startet
den \emph{CorbaSender}-Thread.\\

Beim Starten der Threads, wird sichergestellt, dass alle Zugriff auf alle drei Warteschlangen haben. Die Konsequente Verwendung
der Warteschlangen zur Kommunikation der Threads untereinander löst bereits viele Synchronisationsprobleme. Grundsätzlich findet
Kommunikation zwischen den Threads rein über die Warteschlangen statt. Einzige Ausnahme ist das Abrufen des Ergebnisses eines
gesendeten Kommandos. 

\subsubsection{Synchronisation der Befehlsübertragung}
