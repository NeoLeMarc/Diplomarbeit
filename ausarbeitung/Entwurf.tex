

%%%------------------------------------------------Entwurf -------------------------------------------------------------
\chapter{Entwurf}\label{Entwurf}

In diesem Kapitel wird der Entwurf der zu implementierenden Lösung vorgenommen. Hierzu erfolgt zunächst der Entwurf des Gesamtsystems
im Groben. Dieses Gesamtsystem wird in einzelne Komponenten zerlegt, die danach einzeln genauer spezifiziert werden.
Hierbei wird zwischen Hard- und Software unterschieden. Ein Teil der Softwarekomponenten wird parallel zu dieser 
Arbeit in \cite{Jan} entworfen und implementiert.

\section{Gesamtsystem}
\Abbildungps{!htb}{1}{diagramme/Gesamtuebersicht.pdf}{abbildung_gesamtsystem}{Überblick über das Gesamtsystem}
In dieser Arbeit wird ein System zur Patientenüberwachung entworfen. Dieses System besteht aus einer Kombination
von Soft- und Hardware. Zwischen den einzelnen Komponenten gibt es klar definierte Schnittstellen. Hierdurch ist
gewährleistet, dass die einzelnen Komponenten unabhängig voneinander entworfen und implementiert werden können. Noch nicht
implementierte Komponenten können durch Simulatoren ersetzt werden, so dass bereits fertige Komponenten schon getestet
werden können, ohne dass das Gesamtsystem komplett fertig gestellt werden muss. Dies gewährleistet ein frühzeitiges
Erkennen von Problemen und ermöglichst ein entsprechendes Gegensteuern.\\
\\
Abbildung~\ref{abbildung_gesamtsystem} zeigt, welche Komponenten in dem Gesamtsystem existieren und wie diese
zusammenwirken:

\begin{itemize}
    \item{\emph{Erste-Hilfe-Sensor}:} Der eigentliche Sensor, der zur Überwachung der Patienten eingesetzt wird. Dieser 
                               wird in \cite{Marc} dargestellt. In dieser Arbeit wird dieser Sensor um eine 
                               \emph{ZigBee}-Schnittstelle erweitert. Zur Simulation des erweiterten Sensors
                               wird eine Testplatine entwickelt, die sogenannte \emph{MANVNode}.
    \item{\emph{ZigBee-Router}:} Die Router dienen zur Erweiterung der Reichweite des \emph{ZigBee}-Netzwerkes.
                                 Hierfür wird ein fertiges \emph{ZigBee}-Modul der Firma \emph{Atmel} verwendet.
    \item{\emph{ZigBee-USB-Stick}:} Der \emph{USB}-Stick bildet die Hardwareschnittstelle zwischen Computer und 
                                    \emph{ZigBee}-Netzwerk. Das Design basiert auf einem \emph{ZigBee}-Router,
                                    der um eine \emph{USB}-Schnittstelle erweitert wird.
    \item{\emph{MANVConnector}:} Der Connector fungiert als Adapter, der eine Übersetzung zwischen der 
                                 Hardware des \emph{USB-Sticks} und der \emph{CORBA}-Schnittstelle der \emph{MANVSuite}
                                 vornimmt. Vereinfacht gesprochen handelt es sich um einen Treiber für den 
                                 \emph{ZigBee-USB}-Stick. Der \emph{MANVConnector} kapselt alle hardwarespezifischen
                                 Designentscheidungen. Soll später eine andere Funkschnittstelle wie z.B.
                                 \emph{Bluetooth} oder \emph{WLAN} verwendet werden, so muss lediglich
                                 der \emph{MANVConnector} ausgetauscht werden.
    \item{\emph{MANVServer}:} Der \emph{MANVServer} verwaltet alle Informationen über das Sensornetz. Hierzu
                              wird eine relationale Datenbank verwendet. Er sorgt dafür, dass alle Informationen
                              an den entsprechenden Empfänger zugestellt werden. Die Kommunikation zwischen
                              \emph{MANVServer} und \emph{MANVConnector} erfolgt über \emph{CORBA}. Der 
                              \emph{MANVServer} wurde in \cite{Jan} entwickelt.
    \item{\emph{Client-Anwendungen}:} Die Clientanwendungen, also \emph{MANVGui} und \emph{MANVMobileGui} bilden
                                      die Benutzerschnittstelle des Sensornetzes. Diese wurden ebenfalls
                                      in \cite{Jan} entwickelt. 
\end{itemize}
    

\section{Hardware}
\subsection{MANVNode}
\subsubsection{Beschreibung}
\Abbildungps{!htb}{1.25}{diagramme/platine_manvnode-crop.pdf}{abbildung_manvnode}{Entwurf der Platine der MANVNode.}
\Abbildungps{!htb}{0.4}{diagramme/platine_usbstick-crop.pdf}{platine_usbstick}{Entwurf der Platine des USB-Sticks.}
Die \emph{MANVNode} ist eine Test- und Entwicklungsplatine zum Test der Sensornetzes. Auf ihr befindet sich ein 
\emph{ADuC-7026-Mikrocontroller} der Firma \emph{Analog Devices} sowie ein Atmel ZigBit-Funkmodul des Typs \emph{ATZB-24-A2}. 
Die Platine dient zur Simulation des \emph{Erste-Hilfe-Sensors}. An Stelle einer echten Messung generiert die 
Platine Messwerte mit Hilfe eines Zufallszahlen-Generators. Der Generator kann in drei Zuständen betrieben werden:

\begin{itemize}
    \item{Grün:} Simulation eines Patienten mit gutem Kreislaufzustand. Puls zwischen 60 und 120 Schlägen pro Minute, 
                 Atemzüge pro Minute zwischen 12 und 15. Periodischer Versand der Meldung "`Zustand OK"'.
    \item{Gelb:} Simulation eines Patienten mit beginnend kritischem aber noch nicht akut lebensbedrohlichem 
                 Kreislaufzustand. Puls zwischen 120 und 180 Schlägen pro Minute, Atmung zwischen 60 und 80
                 Zügen pro Minute (Hyperventilation).
    \item{Rot:}  Simulation eines Patienten in kritischem Zustand mit Puls zwischen 0 und 10 (entsprechend
                 Kammerflimmern oder Kreislaufstillstand) sowie Atmung zwischen (0 und 2) mit bestehendem
                 akutem Handlungsbedarf. Priorisierte Generierung einer Alarmmeldung.
\end{itemize}

Zur Einstellung und zum Wechsel der Zustände befinden sich 3 Schalter an der Platine. Der Zustand wird mit Hilfe von
drei farbigen LEDs visualisiert. Zusätzlich kann über einen Piezo-Summer ein Alarm auch akustisch wiedergegeben werden.
Durch die Kombination der drei LEDs werden zusätzlich Status- und Fehlerinformationen der Platine während des 
Initialisierungsvorgangs ausgegeben.

\subsection{Spannungsversorgung}
\nomenclature{mF}{Millifarad}
\nomenclature{LED}{Leuchtdiode}
\nomenclature{Low-Dropout}{Spannungsregler, der mit niedriger Differenz zwischen Eingangs- und 
              Ausgansspannung arbeiten kann.}
Um die Platine möglichst vielseitig einsetzen zu können, wurde Wert auf eine möglichst flexible Spannungsversorgung gelegt. Diese
soll möglichst robust gegenüber Spannungsschwankungen sein. Kern der Spannungsversorgung ist ein 
\emph{Low-Dropout-Spannungsregle}r des Typs \emph{LP2980-3.3} der Firma \emph{National Semiconductor}. Dieser liefert eine stabile
3,3-V-Spannung bei einem maximalen Strom von 50~mA. Die Eingangsspannung kann zwischen 2,1~V und 16~V variiert werden.
Die Spannungsversorgung kann damit z.B. über USB (5~V-Versorgungsspannung), ein externes Netzteil oder eine 
9~V-Blockbatterie gespeist werden. Durch die hohe maximale Versorgungsspannung von 9~V sind Schäden durch versehentliches
Anschließen eines falschen Netzteils weitestgehend ausgeschlossen. Die Spannungsversorgung ist zusätzlich mit einem 
10-mF-Kondensator stabilisiert.

Zusätzlich wurde die die Spannungsversorgung weiter stabilisiert. Hierzu wurde jeder Spannungseingang aller Bauteile der
Platine mit einem 100nF Kondensator gepuffert. Diese sind möglichst nahe an den entsprechenden Versorgungspins angebracht.
Kurzzeitige Spannungsabfälle, wie sie z.B. beim Schalten von LEDs, des Piezo-Summers oder des Aufwachens des ZigBee-Moduls
aus dem Stromsparmodus auftreten können, werden so zuverlässig abgefangen.

\subsection{Programmierschnittstellen}

\subsubsection{Serielle Schnittstellen}
Die \emph{MANVNode}-Platine verfügt über mehrere seriellen Schnittstellen. Im äußeren Bereich der Platine ist eine serielle 
Schnittstelle (JP1) vorhanden, welche die Standardbelegung des Programmierkabels des \emph{ADuC-7026-Evaluationsboards}
besitzt.  Bereits vorhandene Programmierkabel können somit ohne weiteres zur Programmierung des Mikrocontrollers 
verwendet werden.  Zusätzlich besteht die Möglichkeit, auf die serielle Schnittstelle des \emph{ZigBit}-Moduls 
zuzugreifen, worüber das Herunterladen von \emph{Firmware} auf das Modul sowie Einstellung bestimmter 
Parameter\,--\,wie der Netzwerkkennung des Gerätes\,--\,möglich ist.
Der Zugriff erfolgt ebenfalls über die Stiftleiste JP1, allerdings müssen hierfür \emph{RX-} und \emph{TX}-Leitung des 
Programmierkabels vertauscht und alle Jumper des Schalters S1 unterbrochen werden. 

\subsubsection{JTAG}
Die \emph{MANVNode}-Platine verfügt neben der seriellen auch über eine JTAG-Schnittstelle. Diese ermöglich einen Zugriff mit
gängigen Programmierwerkzeugen wie z.B. Eclipse, Crossworks oder \emph{Kyle $\mu{}$Vision.}
Über die Schnittstelle kann sowohl Programmierung als auch Debugging des \emph{ADuC-7026-Mikrocontrollers}
durchgeführt werden. Ein Zugriff auf das \emph{ZigBit} Modul ist allerdings nur indirekt 
möglich\footnote{Einige Werkzeuge bieten die Möglichkeit, eine Konsolenverbindung
über den \emph{UART} des \emph{ADuC-7026-Mikrocontrollers} zu öffnen, um direkt mit dem \emph{ZigBit}-Modul zu
    kommunizieren.}.  Ein Zugriff über \emph{JTAG} ist nicht vorgesehen.

\subsection{LEDs}

\subsubsection{Beschreibung der einzelnen LEDs}
Die \emph{MANVNode}-Platine verfügt insgesamt über 6 LEDs, die zur Anzeige des aktuellen Zustands sowie zur Fehlerdiagnose dienen.
\begin{itemize}
    \item{PWR:} Diese LED befindet sich direkt in der Spannungsversorgung der Platine. Sie leuchtet, sobald
                die Platine mit Spannung versorgt wird. 
    \item{GREEN, YELLOW, RED}: Diese LEDs sind direkt an den Mikrocontroller angeschlossen und visualisieren den Zustand des
                               Zufallszahlengenerators entweder durch dauerhaftes Leuchten (GREEN, YELLOW) oder im Alarmzustand
                               durch schnelles Blinken (RED). 
    \item{BLUE}: Diese LED signalisiert, ob eine Alarmunterdrückung ("`Mute"') besteht.
    \item{ZIGBIT-STATUS}: Diese LED leuchtet, sobald das ZigBit-Modul über das CTS-Signal ("`Clear to send"') die Bereitschaft, 
                          Daten zu empfangen, signalisiert.
\end{itemize}
                 
    

\subsubsection{Diagnosecodes}
Neben den oben dargestellten einfachen Signalisierungen hat die \emph{Firmware} der \emph{MANVNode}-Platine die 
Möglichkeit, über die Kombination obiger LEDs Diagnose- und Fehlercodes auszugeben. Hierbei gilt folgende Codierung:

\begin{itemize}
    \item{GREEN blinkt in 1-Sekunden-Abständen:} Der ADuC-7026-Mikrocontroller befindet sich im Bootmodus. Ein Reset des
                                                    ZigBit-Moduls wurde durchgeführt und es wird nun auf Bereitschaft des Moduls
                                                    gewartet.
    \item{Zweimaliges Blinken von YELLOW:} Eine Verbindung mit dem ZigBit-Modul wurde erfolgreich aufgebaut, es wird nun eine 
                                           Initialisierung vorgenommen.
    \item{RED, GREEN leuchten gleichzeitig:} Das ZigBit-Modul wurde erfolgreich initalisiert, auf die Verbindung mit dem 
                                                Funknetzwerk wird gewartet.
    \item{YELLOW leuchtet dauerhaft länger als 10 Sekunden und
          ZIGBIT-STATUS leuchtet dauerhaft:} Es kann keine Verbindung mit dem Funknetzwerk aufgebaut werden.
    \item{YELLOW leuchtet dauerhaft länger als 10 Sekunden und ZIGBIT-STATUS leuchtet nicht:} Es liegt eine Funktionsstörung des
          ZigBit-Moduls vor.
    \item{ZIGBIT-STATUS leuchtet dauerhaft:} Verbindung mit Funknetzwerk wurde verloren oder Powersafe-Modus ist deaktiviert.
    \item{ZIGBIT-STATUS blinkt im 2-Sekunden-Abstand:} Die Platine arbeitet ordnungsgemäß, es besteht eine Verbindung mit dem
                                                        Funknetzwerk und der Powersafe-Modus ist aktiv.
\end{itemize}
                                                        
\subsubsection{\emph{ZigBee-USB-Stick}}
\Abbildungps{!htb}{0.25}{diagramme/Ansteuerung-USB-Stick.pdf}{label}{Datenfluss zwischen Server und Netzwerk}

Der \emph{ZigBee-USB-Stick} ist die Schnittstelle zwischen Sensornetz und Computer. Es handelt sich um einen 
\emph{USB-Stick}, der ein \emph{ZigBit}-Modul beinhaltet. Zusätzlich sind zwei weitere Bauteile enthalten, die das 
\emph{ZigBit}-Modul mit Strom versorgen sowie eine Umsetzung der \emph{UART}-Schnittstelle des \emph{ZigBit}-Moduls 
auf \emph{USB} vornehmen. Für die Stromversorgung ist es notwendig, die 5~V der
\emph{USB}-Schnittstelle auf die 3~V des \emph{ZigBit}-Moduls umzusetzen.

\section{Software}
\subsection{MANVNode-Firmware}

\subsubsection{Funktionalität}
\nomenclature{Busy-Waiting}{Warten auf ein Ereignis unter Verschwendung von Prozessorleistung.}
\nomenclature{ISR}{Interrupt-Service-Routine}
\nomenclature{Ringpuffer}{Datenstruktur, die sich selbst überschreibt, wenn sie über ein gewisses Maß gefüllt wurde.}
\nomenclature{Treiber}{Softwareprogramm, dass die Ansteuerung eines Hardware-Gerätes übernimmt.}
Die Firmware der \emph{MANVNode} dient dem Entwickeln und Testen eines Treibers für das \emph{ZigBit}-Modul. Dieser
Treiber wird später in den Erste-Hilfe-Sensor integriert werden. Zusätzlich bietet die \emph{MANVNode} Funktionalität,
die zur Simulation des Erste-Hilfe-Sensors gegenüber der \emph{MANVSuite} dient. Hierzu sollen neben dem 
\emph{ZigBit}-Treiber folgende Funktionalitäten integriert werden:

\begin{itemize}
    \item Zufallszahlengenerator zum Senden zufälliger Messwerte.
    \item Änderung des Zustands des Zufallszahlengenerators über Taster.
    \item Ansteuerung von LEDs zur Ausgabe des Zustands des Zufallszahlengenerators.
    \item Ansteuerung eines Piezzo-Summers zur Signalisierung von Alarmen.
\end{itemize}


\subsubsection{Ansteuerung des ZigBit-Moduls}
Das \emph{ZigBit}-Modul ist via \emph{UART} mit der \emph{MANVNode} verbunden und wird über das \emph{SerialNet}-Protokoll
angesprochen.

\subsubsection{Ansteuerung des UARTs}
Zur Vermeidung von \emph{Busy-Waiting} soll der Treiber für den \emph{UART}s als Interrupt-Service-Routine (ISR)
realisiert werden. Die Kommunikation zwischen Firmware und \emph{UART}-Treiber erfolgt über Ringpuffer:
Zu sendende Daten werden von der Firmware in den Sendepuffer gelegt. Sobald der \emph{UART} sendebereit ist, 
soll der \emph{UART}-Treiber die zu sendenden Daten zeilenweise aus dem Ringpuffer entnehmen und an
den \emph{UART} übertragen. Analog dazu funktioniert das Empfangen von Daten: Diese werden vom \emph{UART}-Treiber gelesen
und zeilenweise in den Empfangspuffer gelegt. Die Firmware kann diese nun zeilenweise aus dem Puffer lesen.
Dies entspricht der Semantik einer gepufferten, nicht blockierenden Ein-/Ausgabefunktion.
% Hier Tannenbaum zitieren

\subsubsection{Ansteuerung des ZigBit-Modul}
Die Ansteuerung des \emph{ZigBit}-Moduls soll in folgenden Schritten erfolgen: 

\begin{lstlisting}{frame=entwurfZigBit1}
Uebertrage aktuellen Status
Werte Antwort aus
Arbeite empfangene Befehle ab
Aktiviere den Energiesparmodus
\end{lstlisting}

Diese Schritte können entweder periodisch mittels eines Timer-Interrupts oder als Hauptprogramm in einer Endlosschleife
ausgeführt werden. Wichtig hierbei ist die Berücksichtigung der in Abschnitt~\ref{analyse_kommunikation_mit_zigbit_modul}
beschriebenen Synchronisationsprobleme. Hierbei soll wie folgt vorgegangen werden:

\begin{itemize}
    \item{Behandlung asynchron auftretender Ereignisse:} Hierbei ist vor allem das \emph{DATA}-Ereignis wichtig, über das
    der Empfang von Befehlen von der \emph{MANVSuite} signalisiert wird. Alle anderen Ereignisse können zunächst vernachlässigt
    werden. Ereignisse, die während des Wartens auf einen Statuscode auftreten, sollen zur späteren Behandlung in einen
    Ringpuffer zwischengespeichert werden. Die Abarbeitung soll dann nach Empfang des Statuscodes erfolgen.

    \item{Behandlung komplexer Rückgabewerte:} Im aktuellen Entwurf werden von der Firmware der \emph{MANVNode} keine 
    \emph{SerialNet}-Befehle verwendet, die eine komplexe Rückgabe haben, so dass dieses Problem eigentlich nicht auftreten 
    sollte. Sollten trotzdem komplexe Rückgaben auftreten, so werden diese wie asynchron auftretende Ereignisse behandelt
    und in den Befehlspuffer gelegt. Bei der späteren Auswertung des Befehlspuffers werden diese dann einfach verworfen.
    So bleibt eine Synchronisation mit dem \emph{ZigBit}-Modul in jedem Fall gewährleistet.
\end{itemize}

Die \emph{SerialNet}-Firmware bietet die Möglichkeit, den Energiesparmodus entweder manuell oder aber in einer 
konfigurierbaren Periode automatisch aufzurufen (vgl. Abschnitt~\ref{analyse_powermanagement}). Für die
\emph{MANVNode}-Firmware wird der manuelle Aufruf verwendet, da dieser deutlich flexibler und einfacher zu
implementieren ist als der automatische Modus: Sobald die Übertragung der Zustandsdaten abgeschlossen ist und
alle empfangenen Befehle abgearbeitet wurden, ruft die Firmware über den Befehl \emph{AT+WSLEEP} den Energiesparmodus
auf. Hierdurch ist gewährleistet, dass das \emph{ZigBit}-Modul nur so lange wie zur Bearbeitung aller Aufgaben
notwendig in Betrieb ist. Nachdem das \emph{ZigBit}-Modul aus dem Energiesparmodus zurückkehrt, wird die Abarbeitung
der Ansteuerungsroutine von vorne begonnen. Das Aufwachen aus dem Energiesparmodus wird der \emph{MANVNode}-Firmware
über eine Zustandsänderung des \emph{CTS}-Registers des \emph{UART} signalisiert. Zusätzlich wird der \emph{AT+WSLEEP}
Befehl mit dem Statuscode \emph{OK} quittiert, sobald das \emph{ZigBit}-Modul wieder betriebsbereit ist. 


Insgesamt ergibt sich für die Ansteuerung des \emph{ZigBit}-Moduls folgender Ablauf:

\begin{lstlisting}{frame=entwurfZigBit2}
Uebertrage aktuellen Status
Wiederhole:
    Antwort von ZigBit-Modul lesen
    Falls Antwort != Statusnachricht:
        Antwort in Befehlspuffer legen
bis Antwort == Statusnachricht    
Arbeite Befehlspuffer ab
Aktiviere den Energiesparmodus
\end{lstlisting}

Dieser Ablauf ist in Abbildung~\ref{zigbit_mainloop} als Ablaufdiagramm dargestellt.
\Abbildungps{!htb}{0.5}{diagramme/Flussdiagramm-Firmware-Mainloop.pdf}{zigbit_mainloop}{Ablauf der Ansteuerung des \emph{ZigBit}-Moduls.}

\subsection{MANVSuite}

In dieser Arbeit wurde ein \emph{Java}-Treiber (MANVConnector) entworfen und implemtiert. Dieser Treiber realisiert die 
Anbindung an die von Herrn Tepelmann in \cite{Jan} entwickelte \emph{MANVSuite}. 


\subsection{MANVConnector}
\Abbildungps{!htb}{1.25}{diagramme/manv_connector_sequenzdiagramm_main.pdf}{sequenzdiagramm_manvconnector}{Interaktion der einzelnen Threads des \emph{MANVConnectors}}


Der \emph{MANVConnector} hat einerseits die Aufgabe, Daten, die von dem \emph{ZigBee-USB-Connector} empfangen wurden, in 
\emph{Corba-Events} umzusetzen und an den \emph{MANVServer} weiterzuleiten. Andererseits empfängt sie 
\emph{Corba-Events} vom \emph{MANVServer}, dekodiert diese und sendet sie in Form von Sensornetz-Befehlen an die 
zuständigen \emph{MANVNodes} weiter.

Bei der Kommunikation mit dem auf dem \emph{USB-Stick} aufgebrachten \emph{ZigBee-Modul} stellen sich grundsätzlich 
die selben Synchronisierungsprobleme wie in der \emph{MANVFirmware}. Da der \emph{MANVConnector} jedoch alle 
Möglichkeiten der \emph{Java Virtual Machine} nutzen kann, lassen sich diese deutlich einfacher und eleganter lösen. 

In der \emph{MANVFirmware} werden hierzu mehrere Ringpuffer verwendet, welche die empfangenen Daten speichern. Diese 
finden sich auch im \emph{MANVConnector} wieder. Hierbei werden an Stelle von Ringpuffern priorisierte Warteschlangen, 
sogenannte Queues verwendet. 

\begin{itemize}
    \item{Die \emph{Command Queue}:} In dieser Queue werden alle zu sendenden Befehle gespeichert.
    \item{Die \emph{Event Queue}:} In dieser Queue werden alle empfangenen Ereignisse gespeichert.
    \item{Die \emph{Result Queue}:} In dieser Queue werden alle bereits gesendeten Befehle zusammen mit dem
                             Resultat, das dieser Befehl hatte, gespeichert.
\end{itemize}

Jedes Element der einzelnen Queues verfügt über eine Priorität; die Queues sorgen dafür, dass der
Zugriff nach Priotität sortiert erfolgt. Hierdurch wird sicher gestellt, dass wichtige Ereignisse
wie z.B. Alarme bevorzugt ausgeliefert werden.

Der \emph{MANVConnector} verfügt neben dem Hauptthread über drei weitere \emph{Threads}:

\begin{itemize}
    \item{\emph{SocketWriter}:} Dieser \emph{Thread} entnimmt Befehle aus der \emph{CommandQueue} und sendet
                         diese über den \emph{ZigBee-USB-Stick} an das Sensornetz. Nun blockiert der
                         \emph{Thread} so lange, bis das Ergebnis des Befehls zur Verfügung steht oder
                         eine bestimmte Zeitgrenze überschritten wurde.
                         Sobald dies der Fall ist, wird der Befehl zusammen mit dem Ergebnis in
                         die \emph{ResultQueue} eingefügt. 
    \item{\emph{SocketReader}:} Dieser \emph{Thread} empfängt Daten aus dem Sensornetz. Handelt es sich um ein
                         Ergebnis, so wird dies dem \emph{SocketWrite} signalisiert, und das
                         Ergebnis zur Abholung zur Verfügung gestellt. Handelt es sich hingegen um ein
                         Ereignis, so wird dieses
                         in die \emph{EventQueue} eingefügt.
    \item{\emph{CorbaSender}:} Dieser \emph{Thread} ist für die Kommunikation mit \emph{MANVServer} zuständig.
                         Befehle, die vom \emph{MANVServer} empfangen werden, werden für das 
                         Sensornetz aufbereitet und in die \emph{CommandQueue} eingestellt.
                         Außerdem werden Ereignisse aus der \textsl{EventQueue} entnommen,
                         in \emph{Corba-Events} übersetzt und an den \emph{MANVServer} zugestellt.
\end{itemize}                          

Die Kommunikation der \emph{Threads} untereinander findet komplett über die oben genannten Warteschlangen statt. Das 
Zusammenwirken der \emph{Threads} ist in Abbildung~\ref{sequenzdiagramm_manvconnector} dargestellt:\\

Zunächst erzeugt der \emph{Hauptthread} (\emph{MANVConnector.main}) die drei Warteschlangen. Dannach werden die beiden 
\emph{Threads} \emph{SocketWriter} und \emph{SocketReader} erstellt. Dannach ruft der 
\emph{Hauptthread} die \emph{CORBA}-Initialisierungsroutine auf und startet den \emph{CorbaSender}-\emph{Thread}.\\

Beim Starten der \emph{Threads} wird sichergestellt, dass diese alle Zugriff auf alle drei Warteschlangen haben. Die konsequente 
Verwendung der Warteschlangen zur Kommunikation der \emph{Threads} untereinander löst bereits viele 
Synchronisierungsprobleme. Grundsätzlich findet Kommunikation zwischen den \emph{Threads} rein über die Warteschlangen 
statt. Einzige Ausnahme ist das Abrufen des Ergebnisses eines gesendeten Kommandos. 

\subsubsection{Synchronisierung der Befehlsübertragung}
Bei der Befehlsübertragung muss darauf geachtet werden, dass ein Befehl erst dann gesendet werden darf,
wenn die Abarbeitung aller vorherigen Befehle erfolgt ist, da sonst die Synchronität mit dem \emph{ZigBit}-Modul
nicht mehr gewährleistet ist. Da innerhalb des \emph{MANVConnectors} das Senden in einem anderen \emph{Thread} geschieht
als das Empfangen, erfordert dies besondere Maßnahmen:\\
Um die Synchronisation zu gewährleisten, bietet der \emph{Thread} \emph{SocketReader} eine Schnittstelle, über die der
\emph{SocketSender} das Ergebnis des letzten gesendeten Befehls abholen kann. Diese Schnittstelle verwendet ein sogenanntes
\emph{Latch}, also eine Art von Barriere, um den abholenden \emph{Thread} so lange zu blockieren, bis eine Antwort vorliegt.
Von dem \emph{SocketSender} wird nun verlangt, dass er nach jedem gesendeten Befehl diese Schnittstelle verwendet,
um das Ergebnis des gerade gesendeten Befehls abzuholen. Da der Sender nun so lange, bis das Ergebnis vorliegt, blockiert ist,
kann er auch keine weiteren Befehle senden. Hierdurch wird die geforderte Synchronisierung erreicht. Durch die \emph{JVM}
ist ein korrektes Verhalten des \emph{Latches} sowie der zur Priorisierung verwendeten Warteschlangen garantiert.
