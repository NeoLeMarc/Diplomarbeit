

%%%------------------------------------------------Entwurf -------------------------------------------------------------
\chapter{Entwurf}

\section{Gesamtsystem}
\Abbildungps{!htb}{1}{diagramme/Gesamtuebersicht.pdf}{label}{Überblick über das Gesamtsystem}

\section{Hardware}
\subsection{MANVNode}
\Abbildungps{!htb}{1.05}{diagramme/schaltplan_manvnode.pdf}{label}{Schaltplan der MANVNode}
\Abbildungps{!htb}{1.25}{diagramme/platine_manvnode-crop.pdf}{label}{Entwurf der Platine der MANVNode}
\Abbildungps{!htb}{0.75}{diagramme/platine_manvnode_top.pdf}{label}{Oberseite der Platine der MANVNode}
\Abbildungps{!htb}{0.75}{diagramme/platine_manvnode_bottom.pdf}{label}{Unterseite der Platine der MANVNode}

\subsubsection{Beschreibung}
Die MANVNode ist eine Test- und Entwicklungsplatine zum Test der Sensornetzes. Auf ihr befindet sich ein 
ADuC-7026-Mikrocontroller der Firma Analog Devices sowie ein Atmel ZigBit-Funkmodul des Typs ATZB-24-A2. Die Platine 
dient zur Simulation des Erste-Hilfe-Sensors. An Stelle einer echten Messung generiert die Platine Messwerte mit Hilfe 
eines Zufallszahlen-Generators.
Dier Generator kann in drei Zuständen beschrieben werden:

\begin{itemize}
    \item{Grün:} Simulation eines Patienten mit gutem Kreislaufzustand. Puls zwischen 60 und 120 Schlägen pro Minute, 
                 Atemzüge pro Minute zwischen 12 und 15. Periodischer Versand der Meldung "`Zustand OK"'.
    \item{Gelb:} Simulation eines Patienten mit beginnend kritischem aber noch nicht akut Lebensbedrohlichem 
                 Kreislaufzustand. Puls zwischen 120 und 180 Schlägen pro Minute, Atmung zwischen 60 und 80
                 Zügen pro Minute (Hyperventilation).
    \item{Rot:}  Simulation eines Patienten in kritischem Zustand mit Puls zwischen 0 und 10 (entsprechend
                 Kammerflimmern oder Kreislaufstillstand) sowie Atmung zwischen (0 und 2) mit bestehndem
                 akutem Handlungsbedarf. Priorisierte Generierung eienr Alarmmeldung.
\end{itemize}

Zur Einstellung und Wechsel der Zustände befinden sich 3 Schalter an der Platine. Der Zustand wird mit Hilfe von
drei farbigen LEDs visualisiert. Zusätzlich kann über einen Piezzo-Summer ein Alarm auch akustisch wiedergegeben werden.
Durch die Kombination der drei LEDs werden zusätzlich Status- und Fehlerinformationen der Platine während des 
Initialisierungsvorgangs ausgegeben.

\subsection{Spannungsversorgung}
Um die Platine möglichst vielseitig einzusetzen wurde wert auf eine möglichst flexible Spannungsversorgung gelegt. Diese
soll möglichst Robust gegenüber Spannungsschwankungen sein. Kern der Spannungsversorgung ist ein 
Low-Dropout-Spannungsregler des Typs LP2980-3.3 der Firma National Semiconductor. Dieser liefert eine stabile
3,3V Spannung bei einem maximalen Strom von 50mA. Die Eingangsspannung kann zwischen 2.1V bis 16V variiert werden.
Die Spannungsversorgung kann damit z.B. über USB (5V-Versorgungsspannung), ein externes Netzteil oder eine 
9V-Blockbatterie gespeist werden. Durch die hohe maximale Versorgungsspannung von 9V sind Schäden durch versehentliches
anschließen eines falschen Netzteils weitestgehend ausgeschlossen. Die Spannungsversorgung ist zusätzlich mit einem 10mF 
Kondensator stabilisiert.

Zusätzlich wurde die die Spannungsversorgung weiter stabilisiert. Hierzu wurde jeder Spannungseingang aller Bauteile der
Platine mit einem 100nF Kondensator gepuffert. Diese sind möglichst nahe an den entsprechenden Versorgungspins angebracht.
Kurzzeitige Spannungsabfälle, wie sie z.B. beim Schalten von LEDs, des Piezzo-Summers oder des Aufwachsens des ZigBee-Moduls
aus dem Stromsparmodus auftreten können, werden so zuverlässig abgefangen.

\subsection{Programmierschnittstellen}

\subsubsection{Serielle Schnittstellen}
Die MANV-Node-Platine verfügt über mehrere seriellen Schnittstellen. Im äußeren Bereich der Platine ist eine serielle 
Schnittstelle (JP1) vorhanden, welche der Standardbelegung des Programmierkabels des ADuC-7026-Evaluationsboards besitzt.
Bereits vorhandene Programmierkabel können somit ohne weiteres zur Programmierung des Mikrocontrollers verwendet werden.
Zusätzlich besthet die Möglichkeit, auf die serielle Schnittstelle des ZigBit-Moduls zuzugreifen, worüber das Herunterladen 
von Firmware auf das Modul, sowie der Einstellung bestimmter Parameter wie der Netzwerkkennung des Gerätes möglich ist.
Der Zugriff erfolgt ebenfalls über die Stiftleiste JP1, allerdings muss hierfür RX- und TX-Leitung des Programmierkabels 
verdreht, und alle Jumper des Schalters S1 unterbrochen werden. 

\subsubsection{JTAG}
Die MANV-Node-Platine verfügt neben seriellen auch über eine JTAG-Schnittstelle. Diese ermöglich einen Zugriff mit
gängigen Programmierwerkzeugen wie z.B. Eclipse, Crossworks oder Kyle $\mu{}$Vision. Über die Schnittstelle kann sowohl 
Programmierung als auch Debugging des ADuC-7026-Mikrocontrollers durchgeführt werden. Ein Zugriff auf das ZigBit
Modul ist allerdings nur indirekt möglich\footnote{Einige Werkzeuge bieten die Möglichkeit, eine Consolenverbindung
über den UART des ADuC-7026-Mikrocontrollers zu öffnen, so direkt mit dem ZigBit-Modul kommunikation möglich ist.}.
Ein Zugriff über JTAG ist nicht vorgesehen.

\subsection{LEDs}

\subsubsection{Beschreibung der einzelnen LEDs}
Die MANV-Node-Platine verfügt insgesamt über 6 LEDs, die zur Anzeige des aktuellen Zustands sowie zur Fehlerdiagnose dienen.
\begin{itemize}
    \item{PWR:} Diese LED befindet sich direkt in der Spannungsversorgung der Platine. Diese LED leuchtet, sobald
                die Platine mit Spannung versorgt wird. 
    \item{GREEN, YELLOW, RED}: Diese LEDs sind direkt an den Mikrocontroller angeschlossen und visualisieren den Zustand des
                               Zufallszahlengenrators entweder durch dauerhaftes Leuchten (GREEN, YELLOW) oder im Alarmzustand
                               durch schnelles Blinken (RED). 
    \item{BLUE}: Diese LED signalisiert, ob eine Alarmunterdrückung ("`Mute"') besteht.
    \item{ZIGBIT-STATUS}: Diese LED leuchtet, sobald das ZigBit-Modul über das CTS-Signal ("`Clear to send"') die Bereitschaft, 
                          Daten zu empfangen, signalisiert.
\end{itemize}
                 
    

\subsubsection{Diagnosecodes}
Neben den oben dargestellten einfachen Signalisierungen hat die Firmware der MANV-Node-Platine die Möglichkeit, über die
Kombination obiger LEDs Diagnose und Fehlercodes auszugeben. Hierbei gilt folgende Codierung:

\begin{itemize}
    \item{Led GREEN blinkt in 1-Sekunden-Perioden:} Der ADuC-7026-Mikrocontroller befindet sich im Bootmodus. Ein Reset des
                                                    ZigBit-Moduls wurde durchgeführt und es wird nun auf Bereitschaft des Moduls
                                                    gewartet.
    \item{Zweimaliges Blinken von YELLOW:} Eine Verbindung mit dem ZigBit-Modul wurde erfolgreich aufgebaut, es wird nun eine 
                                           Initialisierung vorgenommen.
    \item{RED, GREEN leuchten gleichzeitig:} Das ZigBit-Modul wurde erfolgreich initalisiert, auf die Verbindung mit dem 
                                                Funknetzwerk wird gewartet.
    \item{YELLOW leuchtet dauerhaft länger als 10 Sekunden und
          ZIGBIT-STATUS leuchtet dauerhaft:} Es kann keine Verbindung mit dem Funktnetzwerk aufgebaut werden.
    \item{YELLOW leuchtet dauerhaft länger als 10 Sekunden und ZIGBIT-STATUS leuchte nicht:} Es liegt eine Funktionsstörung des
          ZigBit-Moduls vor.
    \item{ZIGBIT-STATUS leuchtet dauerhaft:} Verbindung mit Funknetzwerk wurde verloren oder Powersafe-Modus ist deaktiviert.
    \item{ZIGBIT-STATUS blinkt im 2 Sekunden Interval:} Die Platine arbeitet Ordnungsgemäß, es besteht eine Verbindung mit dem
                                                        Funknetzwerk und der Powersafe-Modus ist aktiv.
\end{itemize}
                                                        

\subsection{ADuC}
Beim MANVNode handelt es sich um ein Prototyp des späteren Erste-Hilfe-Sensor für den MANV-Einsatz. Zwar exisitert der 
Erste-Hilfe-Sensor bereits, allerdings hat dieser noch keinerlei Netzwerkfähigkeit. Der Erste-Hilfe-Sensor basiert
auf einem ADuC7019 Microcontroller und ergänzt diesen durch Detektionskomponeten, zur Patientenüberwachung.

Für die Entwicklung der Netzwerkanbindung sind diese Detektionskomponenten nur insofern relevant, dass es zu keiner
Gegenseitigen Störung zwischen Detetion- und Netzwerkkomponeten kommen darf. Daher wurde im ersten Schritt alle nicht
benötigten Komponenten weggelassen, und lediglich der reine Mikrocontroller verwendet. Später wurden die hierbei
entwickelte Netzwerkkomponenten zusammengefasst und in die Hardware des Erste-Hilfe-Sensors integriert.

Die eigentliche Entwicklung fand mit Hilfe eines ADuC7026 Evaluations-Board statt. Dieses Board hat den Vorteil, 
dass alle Anschlüsse des Mikrocontrollers auf Steckerleisten geführt, und damit leicht zugänglich sind. Ausserdem
ist eine JTAG-Schnittstelle vorhanden, die ein einfaches Debuggen des Mikrocontrollers ermöglicht.

\subsection{ZigBee-Schnittstelle}
Für die Anbindung des Erste-Hilfe-Sensors an das Sensornetz wird ein ZigBit-Modul der Firma Atmel verwendet. 
Dieses Modul bietet den Vorteil, dass es bereits über einen kompletten ZigBee-Stack verfügt, der einfach über
AT-Befehle gesteuert werden kann, die per UART gesendet werden.

Der ZigBee-Stack auf dem ZigBit Modul ist austauschbar und kann durch eine eigene Firmware ersetzt werden.
Hierzu wird von der Firma Atmel ein umfangreiches SDK\footnote{Software-Development-Kit: Eine Art Baukasten für
Software, die viele benötigte Teile bereits fertig zur Verfügung stellt} angeboten. Für den Rahmen dieser Diplomarbeit
ist die vorgefertigte Serial-Net-Firmware allerdings ausreichend. Einziger Wermutstropfen ist die fehlende
Verschlüsselung, welche für den Serieneinsatz natürlich erforderlich wäre.

Die Kommunikation mit dem ZigBit Modul erfolgt grundsätzlich synchron. Jeder AT-Befehl wird entweder mit 
"`OK"', "`ERROR"' oder einer Ergebnisszeile quittiert. Der Treiber für das ZigBit-Modul kann also prinzipiell
als endlicher Automat mit zwei Zuständen implementiert werden. Zu beachten ist jedoch, dass prinzipiell
jederzeit Ereignisse vom Typ "`Data Received"' auftreten können. Es ist also notwendig, die Antwort des 
ZigBit Moduls zu parsen, und zu entscheiden, ob es sich um eine Antwort auf einen zuvor gesendeten Befehl
oder aber um ein Data-Ereigniss handelt. Wichtig ist, dass diese Ereignisse nicht verloren gehen dürfen,
da es sich um Befehle handelt, die von der MANVSuite an den Sensor gesendet wurden, und von diesem 
abgearbeitet werden müssen. 


\subsubsection{UART}
Der ADuC verfügt über einen UART Interrupt, welcher eine Statusänderung des UARTs signalisiert. Im Register 
\textsl{COMIEN0} wird konfiguriert, welche Zustände über den Interrupt singnalisiert werden sollen. Tritt
nun einer dieser Zustände auf, so wird der UART Interrupt ausgelöst. Im Interrupthandler muss nun überprüft
werden, welches Ereigniss zum Auslösen des Interrupts geführt hat. Dies ist im Register \textsl{COMSTA0} 
gespeichert. Wichtig ist an dieser Stelle, dass auch mehrere Ereignisse gleichzeitig auftreten können. 
Dies muss im Interrupthandler berücksichtigt werden, da sonst Ereignisse verloren gehen können.

Das eigentliche Senden und Empfangen erfolgt über die beiden Register \textsl{COMRX} und \textsl{COMTX}.
Zum Senden wird hierzu ein einzelnes Zeichen in \textsl{COMTX} gelegt. Nun muss eine gewisse Zeit gewartet
werden, bis das Zeichen gesendet wurde, und das nächste Zeichen in \textsl{COMTX} gelegt werden kann.
FÜr das Empfangen wird das Register \textsl{COMRX} in analoger Weise verwendet werden. Ob das nächste
Zeichen empfangen bzw. gesendet werden kann, kann mit Hilfe der Bits \textsl{DR} ("`Data Ready"' - Daten liegen vor)
bzw. \textsl{TEMT} ("`Transmit Buffer empty"' - Daten können gesendet werden) bestimmt werden.

Die einfachste Methode wäre hierbei, in einer Schleife Busy-Waiting zu betreiben, und so lange zu warten,
bis sich eins der beiden Bits verändert. Dies wäre jedoch sehr aufwendig und würde den Mikrocontroller 
unnötig lange blockieren. Statt dessen wird der Zustand der beiden Register nur dann überprüft, wenn ein 
UART-Interrupt aufgetreten ist.

Zum Senden und Empfangen von Daten werden zwei Ringpuffer verwendet. Möchte ein Unterprogramm Daten senden,
so greift es nicht direkt auf die UART-Schnittstelle zu sondern legt diese Daten lediglich in den Sendepuffer.
Das eigentliche Senden wird nun vom UART-Interrupthandler durchgeführt; das Unterprogramm kann weiter arbeiten,
ohne auf das fertige Senden der Daten warten zu müssen.

Das Empfangen von Daten erfolgt analog. Jedesmal wenn ein Zeichen von der seriellen Schnitstelle empfangen
wurde, wird dieses in den Empfangspuffer gelegt. Das Abarbeiten des Empfangspuffer erfolgt nun als Idle-Task:
Immer dann, wenn der Mikrocontroller gerade keine anderen Aufgaben erfüllen muss, wird der Empfangspuffer
abgearbeitet und eventuell empfangene Befehle werden abgearbeitet. Dies kann natürlich jederzeit durch 
die Abarbeitung von Interrupts unterbrochen werden.

\subsubsection{MANV-USB-Connector}
\Abbildungps{!htb}{0.5}{diagramme/Ansteuerung-USB-Stick.pdf}{label}{Datenfluss zwischen Server und Netzwerk}
\Abbildungps{!htb}{0.4}{diagramme/schaltplan_usbstick.pdf}{label}{Schaltplan des USB-Sticks}
\Abbildungps{!htb}{0.4}{diagramme/platine_usbstick-crop.pdf}{label}{Platine des USB-Sticks}

Der MANV-USB-Connector ist die Schnittstelle zwischen Sensornetz und Computer. Es handelt sich um einen USB-Stick, der einen
ZigBit-Modul beinhaltet. Zusätzlich sind zwei weitere Bauteile enthalten, die das ZigBit-Modul mit Strom versorgen, sowie eine
Umsetzung der UART-Schnittstelle des ZigBit-Moduls auf USB vornehmen. Für die Stromversorgung ist es notwendig, die 5V der
USB-Schnittstelle auf die 3V des ZigBit-Moduls umzusetzen.

\section{Software}

\subsection{Firmware}
\Abbildungps{!htb}{1}{diagramme/Flussdiagramm-Firmware-Mainloop.pdf}{label}{Ablauf der Firmware-Mainloop.}
Die Firmware des Erste-Hilfe-Sensors wurde um einen Treiber für das ZigBit-Modul ergänzt. Die Firware wurde in der
Programmiersprache C geschrieben, und setzt direkt auf die Hardware des ADuC auf. Es wurde lediglich die von 
Rowley Crossworks angebotene Standardbibliothek verwendet, die einige praktische Funktionen wie Stringmanipulation,
einen Interrupthandler und einen fertigen Startup-Code bietet.

Die Entwicklung von Software für einen Microcontroller zeichnet sich durch die Abwesenheit eines Betriebssystems 
aus. Ein Großteil der Funktionalität, die man von der Entwicklung von Software für einen standard Mikrocomputer 
gewohnt ist, ist schlichtweg nicht vorhanden. Hier sind insbesondere eine automatische Speicherverwaltung sowie
Threads und Prozesse zu erwähnen. Da der Erste-Hilfe-Sensor viele Aufgaben gleichzeitig erfüllen muss, stellt 
dies eine ernst zu nehmende Herausforderung dar. Das Problem wurde durch ein Interrupt getriebenes Programmiermodell
gelöst.

Es werden folgende Interrupts verwendet:

Timer0: Dieser Timer-Interrupt führt die Patientenüberwachung durch. Die einzelnen Sensoren werden abgefragt,
und eine Analyse der empfangenen Daten wird durchgeführt.

Timer1: Dieser Interrupt führt einige periodische Aufgaben durch. Zunächst werden die am Sensor vorhandenen
Taster abgefragt (Alarm Stummschalten, Alarm manuell auslösen etc.). Danach wird überprüft, in welchem Zustand
der Sensor sich aktuell befindet, also z.B. ob ein Alarm aufgetreten ist, oder ob der Patient sich in einem
guten Zustand befindet. Abhängig hiervon werden nun LEDs und ein angeschlossener Piezzo-Summer geschaltet,
um den Zustand nach aussen zu signalisieren. Zu letzt wird noch überprüft, wann zuletzt eine Übertragung
des Zustands des Sensors an die MANVSuite erfolgt ist. Liegt dies länger als einen konfiguriertes Zeitintervall
zurück, so wird eine Übertragung des aktuellen Zustands veranlasst.

Ein weiteres Problem sind die sehr beschränkten Ressourcen des Mikrocontrollers. Insbesondere der Speicher ist
mit 16kB sehr knapp bemessen. 

\subsubsection{Synchronisation mit dem ZigBit-Modul}


\subsection{MANVSuite}

In dieser Arbeit wurde ein Java-Treiber (MANVConnector) entworfen und implemtiert. Dieser Treiber realisiert die die 
Anbindung an die von Herrn Tepelmann in \cite{Jan} entwickelte MANVSuite. 


\subsection{MANVConnector}
\begin{sidewaysfigure}
        \includegraphics*[width=1\textwidth]{uml_diagramme/manvconnector_uml.pdf}
        \caption{Klassendiagramm des MANV-Connectors}
        \label{klassendiagramm_manvconnector}
\end{sidewaysfigure}

\Abbildungps{!htb}{1.25}{diagramme/manv_connector_sequenzdiagramm_main.pdf}{sequenzdiagramm_manvconnector}{Interaktion der einzelnen Threads des MANV-Connectors}


Der MANVConnector hat einerseits die Aufgabe, Daten die von dem MANV-USB-Connector empfangen wurden in Corba-Events 
umzusetzen, und an den MANVServer weiterzuleiten. Andererseits empfängt sie Corba-Events vom MANVServer, dekodiert
diese und sendet diese in Form von Sensornetz Befehlen an die zuständigen MANVNodes weiter.

Bei der Kommunikation mit dem auf dem USB-Stick aufgebrachten ZigBee-Modul stellen sich grundsätzlich die selben 
Synchronisierungsprobleme wie in der MANVFirmware. Da der MANVConnector jedoch alle Möglichkeiten der Java-Virtual-Machine
nutzen kann, lassen sich diese deutlich einfacher und eleganter lösen. 

In der MANVFirmware werden hierzu mehrere Ringpuffer verwendet, welche die empfangenen Daten speichern. Diese finden sich auch
im MANVConnector wieder. Hierbei werden an Stelle von Ringpuffern priorisierte Warteschlangen, sogenannte Queues verwendet. 

\begin{itemize}
    \item{Die Command Queue:} In dieser Queue werden alle zu sendenden Befehle gespeichert.
    \item{Die Event Queue:} In dieser Queue werden alle empfangenen Ereignisse gespeichert.
    \item{Die Result Queue:} In dieser Queue werden alle bereits gesendeten Befehle zusammen mit dem
                             Resultat, das dieser Befehl hatte, gespeichert.
\end{itemize}

Jedes Element der einzelnen Queues verfügt über eine Priorität; die Queues sorgen dafür, dass der
Zugriff nach Priotität sortiert erfolgt. Hierdurch wird sicher gestellt, dass wichtige Ereignisse
wie z.B. ein Alarm bevorzugt ausgeliefert werden.

Der MANVConnector verfügt neben dem Hauptthread über drei weitere Threads:

\begin{itemize}
    \item{SocketWriter:} Dieser Thread entnimmt Befehle aus der \textsl{CommandQueue} und sendet
                         diese über den MANV-USB-Connector an das Sensornetz. Nun blockiert der
                         Thread so lange, bis das Ergebnis des Befehls zur Verfügung steht.
                         Sobald dies der Fall ist, wird der Befehl zusammen mit dem Ergebnis in
                         die \textsl{ResultQueue} eingefügt.
    \item{SocketReader:} Dieser Thread empfängt Daten aus dem Sensornetz. Handelt es sich um ein
                         Ergebnis, so wird dies dem \textsl{SocketWrite} signalisiert, und das
                         Ergebnis zur Abholung durch den \textsl{SocketWriter} zur Verfügung
                         gestellt. Handelt es sich hingegen um einen Ereignis, so wird dieses
                         in die \textsl{EventQueue} eingefügt.
    \item{CorbaSender:} Dieser Thread ist für die Kommunikation mit MANVServer zuständig.
                         Befehle, die vom MANVServer empfangen werden, werden für das 
                         Sensornetz aufbereitet und in die CommandQueue eingestellt.
                         Ausserdem werden Ereignisse aus der \textsl{EventQueue} entnommen,
                         in Corba-Events übersetzt und an den MANVServer zugestellt.
\end{itemize}                          

Die Kommunikation der Threads untereinander findet komplett über die oben genannten Warteschlangen statt. Das Zusammenwirken der Threads
ist in Abbildung~\ref{sequenzdiagramm_manvconnector} dargestellt:\\

Zunächst erzeugt der Hauptthread (\emph{MANVConnector.main}) die drei Warteschlangen. Dannach werden die beiden Threads
\emph{SocketWriter} und \emph{SocketReader} erstellt. Dannach ruft der Hauptthread die Corba-Inizialisierungsroutine auf und startet
den \emph{CorbaSender}-Thread.\\

Beim Starten der Threads, wird sichergestellt, dass alle Zugriff auf alle drei Warteschlangen haben. Die Konsequente Verwendung
der Warteschlangen zur Kommunikation der Threads untereinander löst bereits viele Synchronisationsprobleme. Grundsätzlich findet
Kommunikation zwischen den Threads rein über die Warteschlangen statt. Einzige Ausnahme ist das Abrufen des Ergebnisses eines
gesendeten Kommandos. 

\subsubsection{Synchronisation der Befehlsübertragung}
