
%%%------------------------------------------------Grundlagen------------------------------------------------------------------
\chapter{Grundlagen}\label{Grundlagen}

\section{Grundlagen der kabellosen Übetragung}
    \subsection{Paketvermittelte Übertragung}
        Bei der Übertragung von Daten kann grundsätzlich zwischen der Paket- und der Leitungsvermittlung unterschieden 
        werden. Bei der Leitungsvermittlung wird für jeden Kommunikationsvorgang eine eigene Leitung verwendet. 
        Meist wird diesee Leitung zu Beginn der Kommunikation auf- und beim Ende wieder abgebaut. Hierbei wird
        meist ein fester Weg vorgegeben, den die zu sendenden Daten zwischen zwei Partnern zurücklegen. Über diesen Kanal
        gesendete Daten kommen beim Empfänger in genau der selben Reihenfolge an, wie sie vom Sender gesendet wurden.
        Auch steht meist eine garantierte Mindestübertragungsrate zur Verfügung. \\
        Diesen Vorteilen stehen eine Reihe von Nachteilen gegenüber. Für Aufbau und Betrieb der Leitung muss ein gewisser
        Aufwand betrieben werden. Wenn Übertragungsraten garantiert werden, stehen diese ggf. nicht für andere 
        Anwendungen zur Verfügung. Wird die Kapazität der Leitung nicht ausgeschöpft, so bleiben diese Reserven 
        ungenutzt und verfallen.\\
        \\
        Anders verhält sich die Paketvermittlung. In diesem Szenario teilen sich alle Teilnehmer eine gemeinsame
        Leitung. Möchte nun ein Teilnehmer Daten senden, so teilt er diese in kleine Pakete auf, und versieht diese
        mit der Adresse des Empfängers. Nun wird jedes Paket einzeln über die Leitung verschickt. Hierbei landet
        es ggf. bei Zwischenempfängern, dies es jeweils zum nächsten Zwischenempfänger weiterleiten, bis der
        endgültige Empfänger erreicht ist. Da sich nun viele Empfänger eine Leitung teilen, kann eine deutlich bessere
        Auslastung erziehlt werden. Jedoch können nun keine Garantieren mehr über die Reihenfolge, Zuverlässigkeit
        sowie der einem Teilnehmer zur Verfügung stehenden Übertragungsrate getroffen werden.\\
        Diese Probleme können jedoch teilweise in höheren Protokollschichten (z.B. durch Nummerierung und Umsortieren 
        der Pakete beim Empfänger) behandetl werden.

        Bei der kabellosen Datenübertragung teilen sich alle Teilnehmer ein gemeinsames Medium, nämlich die 
        Trägerfrequenzen des verwendeten Funkprotokolls. Eine Vermittlung von einzelnen Leitungen scheidet 
        prinzipbedingt aus, da es nicht möglich ist, einzelne Teilnehmer am senden auf einer Frequenz zu 
        hindern, daher bietet sich die Verwendung eines paketvermittelten Übertragungsprotokolls für kabellose
        Netzwerke besonders an.
        
    \subsection{Frequenzspreizung}
        \Abbildungps{!htb}{1.2}{diagramme/frequenzspreizung_fhss-crop.pdf}{frequenzspreizung_fhss}{Frequenzspreizung mit dem \emph{FHSS}-Verfahren}
        \Abbildungps{!htb}{1.2}{diagramme/frequenzspreizung_dss-crop.pdf}{frequenzspreizung_dsss}{Frequenzspreizung mit dem \emph{DSSS}-Verfahren}
        \subsubsection{Übersicht}
            Bei der Verwendung von kabellosen Übertragungsprotokollen kann es zu einer Vielzahl von 
            Störungen kommen. Übliche Störquelle sind meist andere Protokolle, die im selben Band arbeiten,
            oder elektrische Geräte, die durch ihre Abstrahlung den Funkverkehr stören\footnote{Insbesondere
            sind hier Mikrowellengeräte zu nennen, die im 2.4GHz Band arbeiten}. Aber auch Aufgrund von 
            Mehrwegeausbreitung kann es zu Problemen kommen.\\
            \\
            Da diese Störungen meist nur auf einzelnen Frequenzen vorliegt, kann mit Hilfe der 
            Frequenzspreizung der Einfluß von Störungen reduziert wird. Die Idee ist, nicht mit
            hoher Leistung auf einer einzelnen Frequenz zu senden, sondern die Leistung auf einen
            breiteren Frequenzbereich zu verteilen. Liegt nun eine Störung auf einer einzelnen
            Frequenz vor, kann das Nutzsignal trotzem noch erfolgreich empfangen werden.

        \subsubsection{FHSS: Frequency Hoping Spread Spectrum}\label{FHSS}
            Bei dem \textsl{FHSS}-Verfahren handelt es sich um die einfachste Möglichkeit, ein
            Signal zu spreizen. Hierbei wird einfach nach einer bestimmten Zeiteinheit die
            Sendefrequenz gewechselt, so dass eine Spreizung über ein Zeitintervall erreicht wird.

        \subsubsection{DSSS: Direct Sequence Spred Spectrum}\label{DSSS}
            Bei dem \textsl{FHSSS}-Verfahren wird das Nutzsignal über einen breiten Frequenzbereich
            aufgefächert. Hierzu wird das Nutzsignal mit einem Spreizkode multipliziert. 
            Beim Empfang teilt der Empfänger nun das empfangene Signal durch diesen Spreizcode
            und erhält so das ursprüngliche Signal. Störungen werden hingegen durch die 
            Operation deutlich erkennbar, und können einfach ausgefiltert werden.
        \subsubsection{FHSS vs. DSSS}\label{FHSSvsDSSS}
            \textsl{FHSS} besitzt gegenüber \textsl{DSSS} den Vorteil, dass es mit weniger Hardware
            realisiert werden kann. 
            Dies wird jedoch mit einem höheren Aufwand in der Software erkauft: Kommt es auf einer
            Frequenz zu einer Störung, so geht oft das aktuell gesendete Datenpaket verloren.
            Dies muss von der Software erkannt werden. Eine erneute Übertragung des verlorenen
            Paketes ist erforderlich.\\
            \\
            \textsl{DSSS} ist im Vergleich zu \textsl{FHSS} weniger anfällig gegenüber
            schmallbandigen Störungen, da diese komplett ausgefiltert werden können, 
            wohingegen es beim \textsl{FHSS}-Verfahren zu Paketverlusen kommen kann.
            Liegt jedoch eine breitbandige Störung vor, so ist mit \textsl{FHSS}
            meist noch eine -- wenn auch mit geringerer Übertragungsrate -- Kommunikation
            möglich, wenn diese mit dem \textsl{DSSS}-Verfahren bereits zum erliegen gekommen ist.\\
            \\
            Da das \textsl{DSSS}-Verfahren die Gesamtleistung auf ein breites Spektrum auffächert,
            verursacht es weniger Störungen bei anderen Anwendungen, die im selben Frequenzbereich
            arbeiten. Für diese Anwendungen sieht das Signal aus wie Hintergrundrauschen und kann
            einfach ausgefiltert werden.\\
            \\
            Abschließend bleibt zu sagen, dass jedes der beiden Verfahren eigene Vor- und Nachteile
            besitzt, und dass je nach Anwendung entschieden werden muss, welches Verfahren
            besser geeignet ist.
            

\section{ADuC7019/2X-Mikrocontroller}

    \Abbildungps{!htb}{1}{diagramme/aduc_blockdiagramm.pdf}{aduc_blockdiagramm}{Blockdiagramm des \emph{ADuC7026}-Mikrocontrollers}

    \subsection{Beschreibung}
        Mit der ADuC7019/2X-Serie bietet die Firma Analog Devices eine Familie von voll integrierten Mikrocontroller 
        auf Basis der ARM7-Architektur an. Diese Mikrocontroller zeichnen sich insbesondere durch ihre hohe Anzahl
        an A/D-Wandler-Kanälen an. So verfügt das Modell ADuC7026 beispielsweise über einen 16 A/D-Wandler-Kanäle
        mit einer Abtastrate von einer Million Samples pro Sekunde bei einer Auflösung von 12-Bit. Damit bietet jeder
        der 16 Kanäle eine Datenrate, die etwa dem 17fachen einer gewöhnlichen Audio-CD entspricht.
        Der Mikrocontroller selbst bietet bei einer Frequenz von 41.78 MHz eine maximale Leistung von 41 Millionen
        Befehlen pro Sekunde (MIPS). Zusätzlich ist on-Chip 8 kB SRAM sowie 62kB-Flashspeicher vorhanden. Bei den Modellen
        ADuC7026 und ADuC7027 ist zusätzlich ein externen Speicherbus vorhanden, über bis zu 512kB zusätzlicher SRAM
        angeschlossen werden kann. Bei größerem Speicherbedarf besteht die Möglichkeit, über SPI oder $I^2C$ weiteren SRAM 
        oder Flash-Speicher anzuschliessen.

    \subsection{Peripherie}
        Die Mikrocontroller der ADuC-7019/2X-Familie bieten standardmäßig folgende Peripherie:

        \begin{itemize}
            \item{AD-Wandler:} Bis zu 16 Kanäle mit einer maximalen Abtastrate von 1MSPS bei einer Auflösung von 12-Bit.
            \item{DA-Wandler:} Je nach Typ 2, 3 oder vier Kanäle, mit einer Ausgansspannung zwischen 0 und 2,5V mit einer
                               Auflösung von 12-Bit.
            \item{PWM-Generator:} Flexibler, 3-Phasen Pulsweitenmodulator der bis zu 3 Signalpaare gleichzeitig generieren kann.
            \item{UART-Interface:} Serielle Schnittstelle mit TTL-Pegel.
            \item{SPI-Bus:} Schnittstelle zum Anbinden von bis zu 255 weiteren Peripheriekomponenten.
            \item{$I^2C-Bus$:} 2 $I^2C$-Schnittstellen zur Anbindung weiterer Peripherie.
            \item{PLA:} 2 Blöcke mit jeweils 8 PLA\footnote{Programmierbare Logische Anwendung}-Elementen 
            \item{Timer:} 4 Allzwecktimer/Zähler.
        \end{itemize}
        
        Die einzelnen Modelle der ADuC-7019/2X-Familie unterscheiden sich vor allem durch die Anzahl vorhandener Pins (Bei dem
        kleinsten Modell ADuC-7019 stehen lediglich 40 Pins, beim größten 80 Pins zur Verfügung), die zudemm mehrfach belegt
        sind. Dies bedeutet, dass es nicht Möglich ist, die gesamte Peripherie gleichzeitig zu verwenden. Je nach Anforderung
        ist ggf. die Verwendung eines größeren Modells notwendig. 

\section{Die Atmel ZigBit Familie}
    \subsection{Hardware}
        \Abbildungps{!htb}{1}{diagramme/zigbit_bild.pdf}{zigbit_bild}{Das ZigBit-23-A2R-Modul}
        \Abbildungps{!htb}{1}{diagramme/zigbit_blockdiagramm.pdf}{zigbit_blockdiagramm}{Blockdiagramm des ZigBit-24-A2R-Moduls}

        Atmel bietet unter dem Namen \emph{ZigBit} eine Palette von ZigBee-Modulen an. Diese Module sind in der
        Ansteuerung identisch, unterscheiden sich jedoch vor allem in ihrer Reichweite. Unter der Bezeichnung ATZB-24-A2R
        wird ein Modul für kurze Reichweiten angeboten. Besonderheit an diesem Modul ist, dass es bereits über zwei 
        integrierte Antennen verfügt, so dass es ohne weitere Anpassungen in einem Hardware-Design verwendet werden kann.
        Die ZigBit-Module enthalten einen IEE.802.15.4-Transceiver, einen \emph{ATmega1281}-Mikrocontroller sowie einen
        128kB großen Flash-Speicher. Das Modul kann mittels \emph{UART}, \emph{SPI} oder \emph{$I^2C$} angesteuert werden.\\
        \\
        Ursprünglich wurden die \emph{ZigBit}-Module von der Firma \emph{Meshnetics} entwickelt und verkauft; diese wurde 
        2009 von der Firma \emph{Atmel} gekauft und die Produkte in das Portfolio von \emph{Atme}l integriert.

    \subsection{Firmware}
        \subsubsection{Bitcloud}
            BitCloud ist ein ZigBee-Pro zertifizierter Softwarestack von Atmel. Es werden die Module der \emph{ZigBit}-Familie
            sowie die \emph{RZRAVEN} Evaluationskits unterstützt. BitCloud ist hierbei keine fertige Firmware, sondern 
            Teil eines SDK, dass dazu dient, Anwender beim schnellen und einfachen Entwickeln eigener Firmware zu
            unterstützen. Für Anwender, die selbst keine Firmware implementieren möchten, stellt \emph{SerialNet} eine
            Alternative dar.

        \subsubsection{SerialNet}

            \paragraph{Überblick}

                \emph{SerialNet} ist eine \emph{BitCloud} basierte Firmware, die von Atmel als fertiges Image angeboten
                wird. Dieses kann auf dem \emph{ZigBit}-Modul installiert werden, wodurch die Notwendigkeit der 
                Eigenentwicklung entfällt. \emph{SerialNet} bietet ein einfaches serielles Interface, dass sich mit
                Hilfe von AT-Befehlen\footnote{Der AT-Befehlssatz war früher zur Steuerung von Modems weit verbreitet.} 
                steuern lässt. Der Befehelssatz bietet Zugriff auf fast alle Module des ZigBit-Moduls wie z.B. das
                Versenden und Empfangen von Daten, das schalten von IO-Ports eines entfernten ZigBit-Moduls sowie
                Konfiguration des Energiesparmodus. Nicht möglich ist derzeit eine Verwendung der im \emph{ZigBee}-Standard
                definierten AES-Verschlüsselung, so dass eine Datenübertragung derzeit nur unverschlüsselt erfolgen kann.
                Für den Fokus dieser Diplomarbeit reicht eine unverschlüsselte Verbindung, für den produktiven Einsatz
                müssen jedoch weitere Sicherheitsmaßnahmen ergriffen werden. Wie diese aussehen können ist in 
                Abschnitt~\ref{Sicherheit} beschrieben. 

            \paragraph{SerialNet AT-Protokoll}

                \Abbildungps{!htb}{1.00}{diagramme/serialnet_protokoll.pdf}{serialnet_protokoll}{Darstellung des SerialNet-Protokolls als Zustandsautomat}

                Das SerialNet AT-Protokoll lässt sich vereinfacht als Zustandsautomat mit 3 Zuständen darstellen
                (Vgl. Abbildung~\ref{serialnet_protokoll})\footnote{Zur exakten Darstellung müsste ein weitere 
                    Zustände eingeführt werden, die das Bearbeiten von Befehlen im offline Modus repräsentieren. 
                    Ausserdem wird der Übergang von \emph{offline} zu \emph{online} eigentlich durch eine 
                    \emph{EVENT\_JOINED}-Ereignis ausgelöst, und müsste daher durch ein Epsilon-Übergang dargestellt
                    werden. Diese Details sind jedoch für die Verständnis der prinzipiellen Funktionsweise des 
                    Befehlssatzes unwesentlich.}:

                \begin{itemize}
                    \item{offline:} Es besteht keine Verbindung zu eine \emph{ZigBee}-Netzwerk. Befehle
                                    zur Kommunikation mit anderen Knoten sind nicht verfügbar. 
                                    Ein Zugriff zur Konfiguration der Netzwerkparameter wie 
                                    Netzwerk- und Hardwareadresse sind verfügbar. 

                    \item{online:} Das Modul ist Betriebsbereit, mit einem Netzwerk verbunden und wartet
                                   auf Befehle. Befehle zur Kommunnikation mit anderen Knoten stehen zur
                                   Verfügung, Befehle zur Kommunikation der Netzwerkparameter sind gesperrt.

                    \item{busy:} Das Modul ist mit der Bearbeitung eines Befehls beschäftigt. Es stehen
                                 keine Befehle zur Verfügung - jedoch können jederzeit Ereignisse 
                                 empfangen werden.
                \end{itemize}
                                    
                Grundsätzlich ist das \emph{SerialNet}-Protokoll synchron: Ein Befehl wird immer mit einem der beiden 
                Ergebniscodes \emph{OK} und \emph{ERROR} beantwortet. Bei einigen Befehlen wie z.B. \emph{AT+WCHILDREN}
                kann zusätzlich zum Ergebniscode eine ggf. sogar mehrzeilige Antwort erfolgen. Eine Antwort wird immer
                durch Ausgabe eines Ergebniscodes beendet. Neben dieser synchronen Befehl-Antwort-Folge können jedoch
                jederzeit auch asynchrone Events auftreten. Hierauf muss bei der Entwicklung eines Treibers zur 
                Ansteuerung des Moduls besonders geachtet werden. Die wichtigsten \emph{SerialNet}-Befehle, ihre
                Anwendbarkeit sowie die Art der Antwort sind in Tabelle~\ref{serialnet_befehle} dargestellt.
                Tabelle~\ref{serialnet_events} beeinhaltet die wichtigstens \emph{SerialNet}-Events.

                \begin{table}
                    \begin{tabular}{llll}
                        \textbf{Befehl}  & \textbf{Beschreibung}  & \textbf{Antwort} & \textbf{Anwendbarkeit}\\

                        ATD           & Versenden von Daten               & Einfach & online-Zustand \\
                        ATR           & Entfernten Befehl ausführen       & Komplex & online-Zustand \\
                        AT+WCHILDREN  & Liste aller untergeordneter Nodes & Komplex & nur auf FFD\\
                        AT+WPANID     & Setzen der PAN-Adresse            & Einfach & offline-Zustand \\
                        AT+WCHMASK    & Setzen der Kanalmaske             & Einfach & offline-Zustand \\
                        AT+WLEAVE     & Netzwerk verlassen                & Einfach & online-Zustand \\
                        AT+WJOIN      & Netzwerk beitreten                & Einfach & offline-Zustand \\
                        AT+WAUTONET   & Netzwerk automatisch beitreten    & Einfach & offline-Zustand \\
                        AT+WROLE      & Rolle im Netzwerk Konfigurieren   & Einfach & offline-Zustand \\
                        AT+WPWR       & Powermanagement konfigurieren     & Einfach & offline-Zustand \\
                        AT+WSRC       & Netzwerkadresse konfigurieren     & Einfach & offline-Zustand \\
                        AT+GSN        & Hardwareadresse konfigurieren     & Einfach & offline-Zustand \\
                        AT+WWAIT      & Wartezeit auf Parameter fut ATD   & Einfach & offline-Zustand \\
                    \end{tabular}
                    \caption{Übersicht der wichtigsten \emph{SerialNet}-Befehle}
                    \label{serialnet_befehle}
                \end{table}

                \begin{table}
                    \begin{tabular}{lll}
                        \textbf{Ereignis} & \textbf{Beschreibung} & \textbf{Parameter}\\
                            DATA         & Daten empfangen & Adresse, Länge, Daten \\
                            EVENT:JOINED & Netzwerkverbindung hergestellt & --- \\
                            EVENT:LOST   & Netzwerkverbindung verloren & --- \\
                     \end{tabular}
                     \caption{Übersicht der \emph{SerialNet}-Ereignisse}
                     \label{serialnet_events}
                \end{table}

\section{Java}
    \subsection{Übersicht}

        Java ist eine von Sun Microsystems entwickelte Technologie zur platformunabhängigen 
        Erstellung von Programmen. Sie besteht aus einer Programmiersprache, die ebenfalls den Namen
        Java trägt, einem Compiler (javac) sowie der Java-Laufzeitumgebung (Java-Runtime-Environment - JRE).
        Die Java-Laufzeitumgebung besteht aus einer virtuellen Maschine, die die kompilierten Programme ausführt.
        Dies bietet den Vorteil, dass bei einem Wechsel der Host-Platform (also z.B. von Windows auf Linux oder MacOS) 
        bestehende Programme nicht neu Übersetzt werden müssen.\\

    \subsection{Programmiersprache}
        Java ist eine moderne, statisch typisierte, objektorientierte Programmiersprache. Aufgrund der von C entlehnten 
        Syntax erinnert Java auf den ersten Blick an C++. Bei genauerer Betrachtung unterscheiden sich diese beiden 
        Sprachen jedoch stark. So bietet Java im Gegensatz zu C++ keine Mehrfachvererbung sondern verwendet sogenannte
        Interfaces. Java wird mit einer großen Standardbibliothek ausgeliefert, die für sehr viele Standardaufgaben
        (z.B. Threadverwaltung, Netzwerkkommunikation, GUI-Entwicklung\footnote{GUI: Graphical-User-Interface, dt. 
        graphische Benutzerschnittstelle.} oder typische Datenstrukturen wie Listen und Hashmaps) bereits eine
        passende Lösung mitbringt. Durch den integrierten Packaging-Macheanismus wird darüber hinaus die übersichtliche
        Gliederung des Quelltextes in Unterdateien ermöglicht.\\
        Aufgrund der statischen Typisierung und der genau definierten Laufzeitumgebung eignet sich Java besonders
        gut zur Erstellung von zuverlässigen und fehlerarmen Programmen. Werden konsequent Interfaces verwendet und
        typunsichere Downcasts vermieden, so können die meisten Fehler bereits durch den Compiler erkannt und abgefangen 
        werden. Kann ein solches Programm ohne Fehler und Warnungen kompiliert werden, besteht eine hohe Chance,
        dass auch Laufzeitfehler vermieden werden.\\
        Insbeonsdere wenn mehrere Teilaspekte eines Programms von verschiedenen Programmierern umgesetzt wird, 
        ist die Verwendung von klar definierten Schnittstellen (Interfaces) besonders wichtig, da nur so eine korrekte
        Funktionalität nach dem Zusammensetzen der einzelnen Teile gewährleistet werden kann.

\section{Python}
    Python ist eine moderne, leicht zu erlernende objektorientierte Skriptsprache, die mittlerweile unter fast
    jedem UNIX-artigen Betriebssystem wie Linux, MacOS oder BSD zum Lieferumfang gehört. Darüber hinaus sind
    auch fertige Pakete für Windows verfügbar. Python eignet sich daher besonders zum Schreiben von kleinen
    bis mittelgroßen Skripten. In dieser Diplomarbeit wird Python für die Interaktion mit dem Betriebssystem
    eingesetzt, wenn diese Aufgaben in Java entweder garnicht oder nur sehr schwierig zu Lösen wären. Beispiele
    hierfür sind die automatische Erkennung von \emph{USB-Geräten} oder der Zugriff auf den seriellen Port.
    Da Python eine sehr kompakte und verständliche Implementierung von Programmcode zulässt, wurde in dieser
    Diplomarbeit weitestgehend versucht, auf Beispiele in Pseudocode zu verzichten, und statt dessen lauffähige
    Python Programme zu verwenden. Dies ist nicht nur eindeutiger, sondern bietet gleichzeitig den Vorteil,
    dass die meisten Programmbeispiele direkt in lauffähige Programme übernommen werden können.

\section{Corba}
    Corba (Common Object Request Broker Architecture) ist eine objektorientierte Middleware zur Verteilung von 
    Objekten auf verschiedenen Rechnern innerhalb eines Netzwerkes. Das besondere hierbei ist, dass Corba
    nicht an eine bestimmte Programmiersprache gebunden ist. Die einzelnen Objekte bzw. komponenten können
    hierbei in jeder beliebigen Programmiersprache implementiert werden, die eine Corba-Anbindung besitzt.
    Im Rahmen dieser Diplomarbeit ist diese Programmiersprachenunabhängigkeit sehr wichtig, da bestimmte
    Teile (z.B. die Graphische Oberfläche für Mobiltelefone oder die Ansteuerung des USB-Sticks) nicht in 
    Java realisiert werden können, und statt dessen auf C++ sowie Python ausgewichen werden musste.
