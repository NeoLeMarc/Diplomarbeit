
%%%------------------------------------------------Grundlagen------------------------------------------------------------------
\chapter{Grundlagen}\label{Grundlagen}

In diesem Kapitel werden die in späteren Kapitel vorausgesetzten Grundlagen
erörtert. Hierzu gehören zum einen die Grundlagen der kabellosen Übertragung, zum anderen eine kurze Beschreibung der
Programmiersprachen \emph{Java} und \emph{Python} sowie der \emph{Corba-Middleware}. 

\section{Grundlagen der kabellosen Übetragung}
    \subsection{Paketvermittelte Übertragung}
        Bei der Übertragung von Daten kann grundsätzlich zwischen der Paket- und der Leitungsvermittlung unterschieden 
        werden. Bei der Leitungsvermittlung wird für jeden Kommunikationsvorgang eine eigene Leitung verwendet. 
        Meist wird diese Leitung zu Beginn der Kommunikation auf- und beim Ende wieder abgebaut. Hierbei wird
        meist ein fester Weg vorgegeben, den die zu sendenden Daten zwischen zwei Partnern zurücklegen. Über diesen Kanal
        gesendete Daten kommen beim Empfänger in genau der selben Reihenfolge an, wie sie vom Sender gesendet wurden.
        Auch steht meist eine garantierte Mindestübertragungsrate zur Verfügung. \\
        Diesen Vorteilen steht eine Reihe von Nachteilen gegenüber. Für Aufbau und Betrieb der Leitung muss ein gewisser
        Aufwand betrieben werden. Wenn Übertragungsraten garantiert werden, stehen diese ggf. nicht für andere 
        Anwendungen zur Verfügung. Wird die Kapazität der Leitung nicht ausgeschöpft, so bleiben diese Reserven 
        ungenutzt und verfallen.\\
        \\
        Anders verhält sich die Paketvermittlung. In diesem Szenario teilen sich alle Teilnehmer eine gemeinsame
        Leitung. Möchte nun ein Teilnehmer Daten senden, so teilt er sie in kleine Pakete auf und versieht diese
        mit der Adresse des Empfängers. Nun wird jedes Paket einzeln über die Leitung verschickt. Hierbei passiert 
        es ggf. eine Reihe von Zwischenstationen, die es jeweils zur nächsten Zwischenstation weiterleiten, bis der
        endgültige Empfänger erreicht ist. Da sich nun viele Empfänger eine Leitung teilen, kann eine deutlich bessere
        Auslastung erzielt werden. Jedoch können nun keine Garantien mehr über die Reihenfolge, Zuverlässigkeit
        sowie die einem Teilnehmer zur Verfügung stehende Übertragungsrate gegeben werden.\\
        Diese Probleme können jedoch teilweise in höheren Protokollschichten (z.B. durch Nummerierung und Umsortieren 
        der Pakete beim Empfänger) behandelt werden.

        Bei der kabellosen Datenübertragung teilen sich alle Teilnehmer ein gemeinsames Medium, nämlich die 
        Trägerfrequenzen des verwendeten Funkprotokolls. Eine Vermittlung von einzelnen Leitungen scheidet 
        prinzipbedingt aus, da es nicht möglich ist, einzelne Teilnehmer am Senden auf einer Frequenz zu 
        hindern. Daher bietet sich die Verwendung eines paketvermittelten Übertragungsprotokolls für kabellose
        Netzwerke besonders an.
        
    \subsection{Frequenzspreizung}
        \Abbildungps{!htb}{1.2}{diagramme/frequenzspreizung_fhss-crop.pdf}{frequenzspreizung_fhss}{Frequenzspreizung mit dem \emph{FHSS}-Verfahren}
        \Abbildungps{!htb}{1.2}{diagramme/frequenzspreizung_dss-crop.pdf}{frequenzspreizung_dsss}{Frequenzspreizung mit dem \emph{DSSS}-Verfahren}
        \subsubsection{Übersicht}
            Bei der Verwendung von kabellosen Übertragungsprotokollen kann es zu einer Vielzahl von 
            Störungen kommen. Übliche Störquellen sind andere Protokolle, die im selben Band arbeiten,
            oder elektrische Geräte, die durch ihre Abstrahlung den Funkverkehr stören\footnote{Insbesondere
            sind hier Mikrowellengeräte zu nennen, die im 2.4-GHz-Band arbeiten.}. Aber auch auf Grund von 
            Mehrwegeausbreitung kann es zu Problemen kommen.\\
            \\
            Da diese Störungen meist nur auf einzelnen Frequenzen vorliegen, kann mit Hilfe der 
            Frequenzspreizung der Einfluß von Störungen reduziert werden. Die Idee ist, nicht mit
            hoher Leistung auf einer einzelnen Frequenz zu senden, sondern die Leistung auf einen
            breiteren Frequenzbereich zu verteilen. Liegt nun eine Störung auf einer einzelnen
            Frequenz vor, kann das Nutzsignal trotzem noch erfolgreich empfangen werden.

        \subsubsection{FHSS: Frequency Hoping Spread Spectrum}\label{FHSS}
            \nomenclature{FHSS}{Frequency Hoping Spread Spectrum}
            Bei dem \textsl{FHSS}-Verfahren handelt es sich um die einfachste Möglichkeit, ein
            Signal zu spreizen. Hierbei wird einfach nach einer bestimmten Zeiteidauer die
            Sendefrequenz gewechselt, so dass eine Spreizung über ein Zeitintervall erreicht wird.

        \subsubsection{DSSS: Direct Sequence Spread Spectrum}\label{DSSS}
            \nomenclature{DSSS}{Direct Sequence Spread Spectrum.}
            Bei dem \textsl{DSSS}-Verfahren wird das Nutzsignal über einen breiten Frequenzbereich
            aufgefächert. Hierzu wird das Nutzsignal mit einem Spreizkode multipliziert. 
            Beim Empfang teilt der Empfänger nun das empfangene Signal durch diesen Spreizcode
            und erhält so das ursprüngliche Signal. Störungen werden hingegen durch die 
            Operation deutlich erkennbar und können einfach ausgefiltert werden.
        \subsubsection{FHSS vs. DSSS}\label{FHSSvsDSSS}
            \textsl{FHSS} besitzt gegenüber \textsl{DSSS} den Vorteil, dass es mit weniger Hardware
            realisiert werden kann. 
            Dies wird jedoch mit einem höheren Aufwand in der Software erkauft: Kommt es auf einer
            Frequenz zu einer Störung, so geht oft das aktuell gesendete Datenpaket verloren.
            Dies muss von der Software erkannt werden. Eine erneute Übertragung des verlorenen
            Paketes ist erforderlich.\\
            \\
            \textsl{DSSS} ist im Vergleich zu \textsl{FHSS} weniger anfällig gegenüber
            schmallbandigen Störungen, da diese komplett ausgefiltert werden können, 
            wohingegen es beim \textsl{FHSS}-Verfahren zu Paketverlusten kommen kann.
            Liegt jedoch eine breitbandige Störung vor, so ist mit \textsl{FHSS}
            meist noch eine Kommunikation -- wenn auch mit geringerer Übertragungsrate -- 
            möglich, wenn diese mit dem \textsl{DSSS}-Verfahren bereits zum Erliegen gekommen ist.\\
            \\
            Da das \textsl{DSSS}-Verfahren die Gesamtleistung auf ein breites Spektrum auffächert,
            verursacht es weniger Störungen bei anderen Anwendungen, die im selben Frequenzbereich
            arbeiten. Für diese Anwendungen sieht das Signal aus wie Hintergrundrauschen und kann
            einfach ausgefiltert werden.\\
            \\
            Abschließend bleibt zu sagen, dass jedes der beiden Verfahren eigene Vor- und Nachteile
            besitzt, und dass je nach Anwendung entschieden werden muss, welches Verfahren
            besser geeignet ist.

\section{Java}
    \subsection{Übersicht}
        \nomenclature{Java}{Programmiersprache der Firma Sun Microsystems.}
        \nomenclature{JVM}{Java Virtual Machine}
        \nomenclature{JRE}{Java Runtime Environment} 
        \nomenclature{Host}{Computer, der Dienste anbietet.}
        \nomenclature{Linux}{Freies \emph{UNIX}-artiges Betriebssystem.}
        \nomenclature{UNIX}{Familie von Mehrbenutzerbetriebssystemen.}
        \nomenclature{MacOS}{Betriebssystem der Firma Apple Computer.}
        \nomenclature{Windows}{Betriebssystemfamilie der Firma Microsoft.}
        \nomenclature{VM}{siehe Virtuelle Maschine}

        \emph{Java} ist eine von Sun Microsystems entwickelte Technologie zur platformunabhängigen 
        Erstellung von Programmen. Sie besteht aus einer Programmiersprache, die ebenfalls den Namen
        \emph{Java} trägt, einem Compiler (\emph{javac}) sowie der \emph{Java-Laufzeitumgebung} 
        (\emph{Java-Runtime-Environment} - \emph{JRE}).
        Die \emph{Java-Laufzeitumgebung} besteht aus einer virtuellen Maschine, die die kompilierten Programme ausführt.
        Dies bietet den Vorteil, dass bei einem Wechsel der Host-Plattform (also z.B. von \emph{Windows} auf \emph{Linux}
        oder \emph{MacOS}) bestehende Programme nicht neu übersetzt werden müssen.\\

    \subsection{Programmiersprache}
        \nomenclature{C}{Imperative Programmiersprache, insbesonders zur hardwarenahen Entwicklung.}
        \nomenclature{C++}{Objektorientierte Programmiersprache auf Grundlage von \emph{C}.}
        \nomenclature{Vererbung}{Mechanismus zur Wiederverwendung von Oberklassenimplementierungen in einer Unterklasse.}
        \nomenclature{Klasse}{Datenstruktur, die Eigenschaften, Attribute und Methoden eines Objektes beschreibt.}
        \nomenclature{Interface}{Beschreibung der Schnittstelle eines Objektes über Signaturlisten.}
        \nomenclature{Signatur}{Typ und Name einer Methode sowie ihrer Parameter.}
        \nomenclature{Thread}{Ausführungsstrang eines Programms. Ein Programm kann mehrere Threads haben, die parallel 
                              arbeiten.}
        \nomenclature{Prozess}{Menge von einem oder mehreren Threads inklusive eines dazugehörigen Speicherbereiches.}
        \nomenclature{GUI}{Graphische Benutzeroberfläche.}
        \nomenclature{Hashmap}{Datenstruktur, die aus Paaren aus Schlüsseln und Werten besteht. Auch bekannt als
                            assoziatives \emph{Array} oder \emph{Record}.} 
        \nomenclature{Cast}{Ändern des statischen Datentyps einer Variable auf einen anderen Typ.}
        \emph{Java} ist eine moderne, statisch typisierte, objektorientierte Programmiersprache. Aufgrund der von 
        \emph{C} entlehnten Syntax erinnert \emph{Java} auf den ersten Blick an \emph{C++}. Bei genauerer 
        Betrachtung unterscheiden sich diese beiden Sprachen jedoch stark. So bietet \emph{Java} im Gegensatz zu 
        \emph{C++} keine Mehrfachvererbung, sondern verwendet sogenannte \emph{Interfaces}. \emph{Java} wird mit einer 
        großen Standardbibliothek ausgeliefert, die für sehr viele Standardaufgaben
        (z.B. \emph{Threadverwaltung}, Netzwerkkommunikation, \emph{GUI}-Entwicklung\footnote{GUI: 
         \emph{Graphical User Interface}, dt.  graphische Benutzerschnittstelle.} oder typische Datenstrukturen wie Listen und
         \emph{Hashmaps}) bereits eine
        passende Lösung mitbringt. Durch den integrierten Paketmechanismus wird darüber hinaus die übersichtliche
        Gliederung des Quelltextes in Unterdateien ermöglicht.\\
        Aufgrund der statischen Typisierung und der genau definierten Laufzeitumgebung eignet sich \emph{Java} besonders
        gut zur Erstellung von zuverlässigen und fehlerarmen Programmen. Werden konsequent Interfaces verwendet und
        typunsichere \emph{Downcasts} vermieden, so können die meisten Fehler bereits durch den Compiler erkannt und 
        abgefangen werden. Kann ein solches Programm ohne Fehler und Warnungen kompiliert werden, besteht eine hohe Chance,
        dass auch Laufzeitfehler vermieden werden.\\
        Insbsondere wenn mehrere Teilaspekte eines Programms von verschiedenen Programmierern umgesetzt werden, 
        ist die Verwendung von klar definierten Schnittstellen (\emph{Interfaces}) besonders wichtig, da nur so eine korrekte
        Funktionalität nach dem Zusammensetzen der einzelnen Teile gewährleistet werden kann.

\section{Python}
    \nomenclature{Python}{Objektorientierte Skriptsprache.}
    \nomenclature{BSD}{\emph{UNIX}-artiges Betriebssystem.}
    \nomenclature{USB}{Universal Serial Bus -- Universelle Schnittstelle, die seit ca. 2000 an nahezu jedem PC vorhanden ist.}
    \nomenclature{Skripstprache}{Programmiersprache, deren Quellcode nicht kompiliert wird.}
    \nomenclature{Kompilieren}{Übersetzen des Quellcodes eines Programms in ausführbaren Binärcode.}
    \nomenclature{Pseudocode}{Vereinfachter Quellcode zur einfachen Beschreibung von Algorithmen.}
    \emph{Python} ist eine moderne, leicht zu erlernende objektorientierte \emph{Skriptsprache}, die mittlerweile 
    unter fast jedem \emph{UNIX}-artigen Betriebssystem wie \emph{Linux}, \emph{MacOS} oder \emph{BSD} zum Lieferumfang 
    gehört. Darüber hinaus sind auch fertige Pakete für \emph{Windows} verfügbar. \emph{Python} eignet sich daher 
    besonders zum Schreiben von kleinen
    bis mittelgroßen Skripten. In dieser Diplomarbeit wird \emph{Python} für die Interaktion mit dem Betriebssystem
    eingesetzt, wenn diese Aufgaben in \emph{Java} entweder gar nicht oder nur sehr schwierig zu lösen wären. Beispiele
    hierfür sind die automatische Erkennung von \emph{USB}-Geräten oder der Zugriff auf den seriellen Port.
    Da \emph{Python} eine sehr kompakte und verständliche Implementierung von Programmcode zulässt, wurde in dieser
    Diplomarbeit weitestgehend versucht, auf Beispiele in Pseudocode zu verzichten, und statt dessen lauffähige
    \emph{Python}-Programme zu verwenden. Dies ist nicht nur eindeutiger, sondern bietet gleichzeitig den Vorteil,
    dass die meisten Programmbeispiele direkt in lauffähige Programme übernommen werden können.

\section{Corba}
    \nomenclature{Corba}{Hier: Programmiersprachen-unabhängige Middleware.}
    \nomenclature{Middleware}{Softwarelösung zum Zugriff auf von Objekten auf entfernten Rechnern.}
    \emph{Corba} (\emph{Common Object Request Broker Architecture}) ist eine objektorientierte \emph{Middleware} 
    zur Verteilung von Objekten auf verschiedenen Rechnern innerhalb eines Netzwerkes. Das besondere hierbei ist, 
    dass \emph{Corba} nicht an eine bestimmte Programmiersprache gebunden ist. Die einzelnen Objekte bzw. Komponenten 
    können hierbei in jeder beliebigen Programmiersprache implementiert werden, die eine \emph{Corba}-Anbindung besitzt.
    Im Rahmen dieser Diplomarbeit ist diese Programmiersprachenunabhängigkeit sehr wichtig, da bestimmte
    Teile (z.B. die Graphische Oberfläche für Mobiltelefone oder die Ansteuerung des \emph{USB-Sticks}) nicht in 
    \emph{Java} realisiert werden können, und statt dessen auf \emph{C++} sowie \emph{Python} ausgewichen werden muss.
