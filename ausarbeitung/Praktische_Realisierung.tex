
%%%-----------------------------------------------UMSETZUNG/VORBEREITUNGEN-------------------------------------------------------------
\chapter{Praktische Realisierung des Sensornetzes}

\section{Hardware}
\subsection{Anbindung des ZigBit-Moduls an den USB-Port}
Das \emph{ZigBit}-Modul kann grundsätzlich entweder über \emph{SPI} oder \emph{UART} angesprochen werden. 
Zur Realisierung des USB-Sticks bietet sich die Verwendung des \emph{UARTs} an, da eine breite Palette 
von fertigen ICs zur Verfügung steht, mit deren Hilfe ein \emph{UART} an einen \emph{USB}-Bus angebunden werden 
kann. Auf Seiten des Betriebssystems präsentiert sich der IC wie ein serieller Port und kann softwareseitig
wie ein solcher angesprochen werden. Die Firma \emph{Embedded Projects} bietet mit der \emph{USB-UART-Bridge}
bereits eine fertige Lösung an, auf der ein entsprechender IC, ein Spannungsregler für 3.3V-Versorgungsspannung
sowie ein USB-Anschluss bereits integriert sind. Das \emph{ZigBit}-Modul wird nun auf die in 
Abbildung~\ref{platine_usbstick} dargestellte Platine aufgelötet. Diese Platine kann nun selbst mit Hilfe einer
Stiftleiste huckepack auf die \emph{USB-UART-Bridge} aufgelötet werden, um die nötige Formstabilität zu erhalten.

\subsection{Herstellung und Bestückung der Platine der \emph{MANVNode}}
\Abbildungps{!htb}{1}{diagramme/manvnode.jpg}{manvnode}{Fertig bestückte Platine der \emph{MANVNode.}}
Die Herstellung der Platine für der \emph{MANVNode} stellte sich als problematischer heraus, als ursprünglich 
angenommen. Zunächst wurde versucht, Prototypen der Platinen im Ätzverfahren selbst herzustellen. Aufgrund der 
für die Durchführungen notwendigen Bohrungen war eine sehr genaue Ausrichtung der Oberseite mit der Unterseite 
der Platine notwendig. Ausserdem war diese Platine sehr empfindlich, so dass sich Leiterbahnen beim Löten
sehr schnell ablösten. Nach einigen ersten Fehlversuchen wurde daher die Entscheidung getroffen, die Platinen
von einem Auftragsfertigern herstellen zu lassen. Für die Prototypen wurde hierbei auf die Aufbringung von 
Lötstopplack verzichtet, damit eventuelle Fehler im Layout später noch korrigiert werden können. Insgesamt waren
zwei Iterationen notwendig, bis alle Fehler beseitigt waren. Am schwerwiegendsten war ein Fehler in der 
Stromversorgung: Der \emph{ADuC-7026}-Mikrocontroller benötigt drei 470nF-Kondensatoren zur Stabilisierung der
Stromversorgung. Diese waren in den ersten beiden Versionen der Platine zu weit vom Mikrocontroller entfernt 
aufgebracht worden. Dies führte dazu, dass der Mikrocontroller beim Flashvorgang, bei welchem ein Strom von fast
40mA benötigt wird, dazu neigt, spontan abzustürzen. Besonders ärgerlich hierbei war, dass der Fehler nur manchmal
auftrat, wodurch er sehr schwer zu reproduzieren war. Nachdem der Abstand zwischen Mikrocontroller und Kondensatoren
verringert wurde, traten diese Abstürze nichtmehr auf, und der Mikrocontroller funktionierte zuverlässig. Zusätzlich
wurde ab Version 1.2 ein Uhrenquarz verwendet, welches das Timingverhalten der Platine verbessert. Ein weiteres
Problem der Versionen bis Versionsnummer 1.2 war, dass die Signalleitungen zwischen \emph{ZigBit}-Modul und
Mikrocontroller verdreht sind. Dieses Problem lässt sich zwar mit einer einfachen Drahtbrücke beheben, ist aber
natürlich trotzdem unschön. In der Hardwareversion 1.3 sind diese Probleme behoben. Diese Platine wurde auch bereits
mit Lötstopplack gefertigt.  

\section{Firmware}
\subsection{Implementierung}
Die Firmware des Erste-Hilfe-Sensors wurde um einen Treiber für das ZigBit-Modul ergänzt. Die Firware wurde in der
Programmiersprache C geschrieben, und setzt direkt auf die Hardware des ADuC auf. Es wurde lediglich die von 
Rowley Crossworks angebotene Standardbibliothek verwendet, die einige praktische Funktionen wie Stringmanipulation,
einen Interrupthandler und einen fertigen Startup-Code bietet.

Die Entwicklung von Software für einen Microcontroller zeichnet sich durch die Abwesenheit eines Betriebssystems 
aus. Ein Großteil der Funktionalität, die man von der Entwicklung von Software für einen standard Mikrocomputer 
gewohnt ist, ist schlichtweg nicht vorhanden. Hier sind insbesondere eine automatische Speicherverwaltung sowie
Threads und Prozesse zu erwähnen. Da der Erste-Hilfe-Sensor viele Aufgaben gleichzeitig erfüllen muss, stellt 
dies eine ernst zu nehmende Herausforderung dar. Das Problem wurde durch ein Interrupt getriebenes Programmiermodell
gelöst.

Es werden folgende Interrupts verwendet:

Timer0: Dieser Timer-Interrupt führt die Patientenüberwachung durch. Die einzelnen Sensoren werden abgefragt,
und eine Analyse der empfangenen Daten wird durchgeführt.

Timer1: Dieser Interrupt führt einige periodische Aufgaben durch. Zunächst werden die am Sensor vorhandenen
Taster abgefragt (Alarm Stummschalten, Alarm manuell auslösen etc.). Danach wird überprüft, in welchem Zustand
der Sensor sich aktuell befindet, also z.B. ob ein Alarm aufgetreten ist, oder ob der Patient sich in einem
guten Zustand befindet. Abhängig hiervon werden nun LEDs und ein angeschlossener Piezzo-Summer geschaltet,
um den Zustand nach aussen zu signalisieren. Zu letzt wird noch überprüft, wann zuletzt eine Übertragung
des Zustands des Sensors an die MANVSuite erfolgt ist. Liegt dies länger als einen konfiguriertes Zeitintervall
zurück, so wird eine Übertragung des aktuellen Zustands veranlasst.

Ein weiteres Problem sind die sehr beschränkten Ressourcen des Mikrocontrollers. Insbesondere der Speicher ist
mit 16kB sehr knapp bemessen. 


\subsubsection{Zugriff auf UART}
Der ADuC verfügt über einen UART Interrupt, welcher eine Statusänderung des UARTs signalisiert. Im Register 
\textsl{COMIEN0} wird konfiguriert, welche Zustände über den Interrupt singnalisiert werden sollen. Tritt
nun einer dieser Zustände auf, so wird der UART Interrupt ausgelöst. Im Interrupthandler muss nun überprüft
werden, welches Ereigniss zum Auslösen des Interrupts geführt hat. Dies ist im Register \textsl{COMSTA0} 
gespeichert. Wichtig ist an dieser Stelle, dass auch mehrere Ereignisse gleichzeitig auftreten können. 
Dies muss im Interrupthandler berücksichtigt werden, da sonst Ereignisse verloren gehen können.

Das eigentliche Senden und Empfangen erfolgt über die beiden Register \textsl{COMRX} und \textsl{COMTX}.
Zum Senden wird hierzu ein einzelnes Zeichen in \textsl{COMTX} gelegt. Nun muss eine gewisse Zeit gewartet
werden, bis das Zeichen gesendet wurde, und das nächste Zeichen in \textsl{COMTX} gelegt werden kann.
FÜr das Empfangen wird das Register \textsl{COMRX} in analoger Weise verwendet werden. Ob das nächste
Zeichen empfangen bzw. gesendet werden kann, kann mit Hilfe der Bits \textsl{DR} ("`Data Ready"' - Daten liegen vor)
bzw. \textsl{TEMT} ("`Transmit Buffer empty"' - Daten können gesendet werden) bestimmt werden.

Die einfachste Methode wäre hierbei, in einer Schleife Busy-Waiting zu betreiben, und so lange zu warten,
bis sich eins der beiden Bits verändert. Dies wäre jedoch sehr aufwendig und würde den Mikrocontroller 
unnötig lange blockieren. Statt dessen wird der Zustand der beiden Register nur dann überprüft, wenn ein 
UART-Interrupt aufgetreten ist.

Zum Senden und Empfangen von Daten werden zwei Ringpuffer verwendet. Möchte ein Unterprogramm Daten senden,
so greift es nicht direkt auf die UART-Schnittstelle zu sondern legt diese Daten lediglich in den Sendepuffer.
Das eigentliche Senden wird nun vom UART-Interrupthandler durchgeführt; das Unterprogramm kann weiter arbeiten,
ohne auf das fertige Senden der Daten warten zu müssen.

Das Empfangen von Daten erfolgt analog. Jedesmal wenn ein Zeichen von der seriellen Schnitstelle empfangen
wurde, wird dieses in den Empfangspuffer gelegt. Das Abarbeiten des Empfangspuffer erfolgt nun als Idle-Task:
Immer dann, wenn der Mikrocontroller gerade keine anderen Aufgaben erfüllen muss, wird der Empfangspuffer
abgearbeitet und eventuell empfangene Befehle werden abgearbeitet. Dies kann natürlich jederzeit durch 
die Abarbeitung von Interrupts unterbrochen werden.

\section{MANVConnector}

\subsection{Zugriff auf die serielle Schnittstelle}
Der Zugriff auf die serielle Schnittstelle mittels Java bringt einige praktische Probleme mit sich.
Der Java-Standard bietet von Haus aus keine Möglichkeit, auf die serielle Schnittstelle zuzugreifen.
Zwar gibt es einzelne Lösungen von Drittanbietern wie z.B. \emph{RxTx} oder \emph{JavaComm}, allerdings
sind diese meist platformabhängig und funktionieren meist nur auf wenigen Betriebssystemen. Da die
in dieser Diplomarbeit entworfene Lösung auf möglichst vielen Betriebssystemen einsetzbar sein soll, 
wurde entschieden, den Zugriff auf die serielle Schnittstelle statt dessen in einem austauschbaren
Modul zu kapseln. Der Zugriff auf das Modul erfolgt über eine Socketverbindung, welche in Java
standardmässig verfügbar ist. Das Modul kann nun in jeder beliebigen Programmiersprache implementiert
werden. Es ist z.B. möglich, für verschiedene Betriebssysteme verschiedene Module anzubieten.
Für die Zwecke dieser Diplomarbeit wurde beispielhaft ein Modul für \emph{UNIX} in der Programmiersprache
Python implementiert, welche unter vielen \emph{UNIX}-artigen Betriebssystemen wie Linux, MacOS, BSD und co.
bereits zur Standardinstallation gehört. Lediglich das \emph{PySerial}-Modul muss nachinstalliert werden.
% TODO: Hier Zitat des PySerial Moduls

\begin{lstlisting}{frame=praktisch1}
#!/usr/bin/env python -OO
# MANV-Sensor - Serial to socket
# for Java to ZigBit connector 

PORT = 4711 ## Port fuer Socketverbindung.
import serial, socket, select, sys, SocketServer, time

class MANVSerialToSocketHandler(SocketServer.BaseRequestHandler):

    def handle(self):
        ## Handler-Hook, in den der SocketServer einsteigt
        print "Connection to socket opened"
        self.openSerial()

        print "Serial connected"
        self.tunnel()

    def openSerial(self):
        ## Serielle Schnittstelle oeffnen.
        ## Welche das genau ist, wird auf der Kommandozeile als 
        ## Parameter uebergeben.
        self.serial = serial.Serial(sys.argv[1], 38400, timeout=1)

    def shutdown(self):
        ## Socket-Verbidung wird geschlossen -> aufraeumen
        self.serial.close()

    def tunnel(self):
        ## Beginn des Tunnelmodus.
        ## Weiterleiten von Daten:
        ## Socket -> Serial
        ## Serial -> Socket
        end = False
        print "Entering tunnel mode"

        while not end:
            ## Select verwenden, um socket und seriellen Port 
            ## ressourcensparend zu ueberwachen. Funktioniert
            ## leider nur unter UNIX.
            readylist = select.select((self.request, self.serial),
                                      (), ())

            ## Behandeln alle empfangenen Daten
            for readysocket in readylist[0]:

                ## Fallunterscheidung zwischen seriellem Port und 
                ## Socket, da hier die Semantik unterschiedlich ist.
                if readysocket == self.serial:

                    ## Daten  wurden auf seriellem Port empfangen
                    ## -> auf socket schreiben.
                    data = self.serial.read(1024)
                    self.request.send(data)

                elif readysocket == self.request:

                    ## Daten wurden auf Socket empfangen
                    ## -> auf seriellen Port schreiben
                    data = self.request.recv(1024)

                    if data:
                        self.serial.write(data)

                    else:
                        ## EOF empfangen -> shutdown
                        end = True

                ## select hat etwas zurueck geliefert, das weder 
                ## Socket noch serieller Port ist -> shutdown
                else:
                    data = ""
                    end = True

                ## Daten zu Debuggingzwecken auf Konsole 
                ## ausgeben.
                print data

        ## Aufraeumen: Seriellen Port schliessen 
        self.serial.close()
        self.request.close()
        print "Leaving tunnel mode"


class ReusableServer(SocketServer.TCPServer):

    def server_bind(self):
        ## Socket wiederverwendbar machen.
        ## Wenn man das nicht tut, ist er nach Beenden 
        ## des Programms fuer 5 Minuten nicht ansprechbar.
        self.socket.setsockopt(socket.SOL_SOCKET,
                               socket.SO_REUSEADDR, 1)
        self.socket.bind(self.server_address)

## Einstiegspunkt 
if __name__ == '__main__':
      server = ReusableServer(('localhost', PORT), 
                              MANVSerialToSocketHandler)
      server.serve_forever()
\end{lstlisting}

Für die Überwachung von Socket und seriellem Port wird in diesem Programm der Systemaufruf
\emph{select()} verwendet. Wird dieser aufgerufen, gibt das Programm so lange den Prozessor
für andere Programme frei, bis Daten empfangen wurden. Sobald dies der Fall ist, kehrt
der \emph{select()}-Aufruf zurück, und liefert eine Liste mit allen Quellen, von denen Daten
empfangen wurden, zurück. Diese können nun mit den entsprechenden Aufrufen von \emph{recv()} 
(im Falle von Sockets) bzw. \emph{read()} (für den seriellen Port) abgeholt werden.
Diese Lösung funktioniert jedoch in dieser Form nur unter UNIX. Unter Windows steht der 
\emph{select()}-Aufruf zwar zur Verfügung, jedoch ist es hier nicht möglich, diesen zur
Überwachung des seriellen Ports zu verwenden. Das obige Programm lässt sich hier jedoch
recht einfach durch die Verwendung von Threads anpassen, in dem für jede Richtung (Also
Seriell $\rightarrow{}$ Socket und Socket $\leftarrow{}$ Seriell) jeweils ein eigener Thread verwendet
wird. Alternativ empfiehlt sich eine Implementierung mit Hilfe der Programmiersprache \emph{C++}.

\subsection{Automatische Erkennung des \emph{ZigBit}-USB-Sticks}\label{usb_stick_erkennen}

Bei der Verwendung von \emph{USB}-Geräten stellt sich bei vielen Betriebssystemen das Problem,
dass die Benennung bei jedem Einstecken des Gerätes anders sein kann. Dies kann insbesondere
dann auftreten, wenn mehrere gleichartige Geräte am \emph{USB}-Bus (z.B. mehrere \emph{USB}-Serial
Geräte) vorhanden sind. Um nicht nach jedem Einsteckvorgang oder Neustart des Betriebssystems die
Konfiguration des \emph{MANV-Connectors} anpassen zu müssen, wird der Name des \emph{USB}-Sticks
nicht fest konfiguriert sondern statt dessen eine automatische Erkennung durchgeführt.
Unter Linux stehen mit \emph{libusb} und dem \emph{/sys}-Dateisystem zwei geeignete Werkzeuge
zur Verfügung, um diese Erkennung durchzuführen.\\
Zunächst werden mit Hilfe der \emph{libusb} alle USB-Busse nach dem auf dem \emph{ZigBit}-\emph{USB}-Stick
verwendeten IC vom Typ \emph{cp210x} durchsucht. Dieser hat die Herstellerkennung \emph{0x10C4} und die
Produktkennung \emph{0xEA60}. Unter Python steht mit \emph{python-usb} eine geeignete Schnittstelle zu
\emph{libusb} zur Verfügung.

\begin{lstlisting}{frame=praktisch2}
import usb
def searchUSB(self):

    ## Durchsuchen alle USB-Busse 
    for bus in usb.busses():

        ## Durchsuchen aller Geraete dieses Busses
        for dev in bus.devices:

            ## Betrachten der Vendor-ID und der Produkt-ID
            if dev.idVendor == 0x10c4 and dev.idProduct == 0xea60:
               
                ## Ein entsprechendes Geraet wurde gefunden,
                ## wir geben dieses zurueck 
                return (bus.dirname, dev.filename)
   
    print "No devices found on USB-Bus."
    return False
\end{lstlisting}

Wenn am USB-Bus kein entsprechendes Gerät gefunden wurde, kann bereites jetzt die Suche abgebrochen werden.
Wird jedoch ein passendes Gerät gefunden, müssen zunächst alle passenden Device-Nodes im \emph{/dev} 
Verzeichnis gefunden werden. Hierzu bietet sich eine Suche im \emph{/sys}-Dateisystem an. Hierfür sind keine
externen Module notwendig, es können die normalen Dateisystem-Operationen des \emph{OS}-Moduls verwendet werden:

\begin{lstlisting}{frame=praktisch3}
import os
def searchSYS(self):

    ## Suchen aller usb-serial Geraete ueber /sys 
    devices = []

    for device in os.listdir('/sys/bus/usb-serial/devices'):
        ## Alle Geraete in Rueckgabe einfuegen
        devices.append(device)

    return devices
\end{lstlisting}

Da an den USB-Bus beliebige USB-Serial-Geräte angeschlossen sein können\footnote{Während der Entwicklung
was es nicht ungewöhnlich, dass bis zu 3 Geräte angeschlossen waren: Bei einem handelte es sich um den
ZigBit-USB-Stick, zwei weitere dienten zum Flashen und Debuggen der angeschlossenen Mikrocontroller.}, 
muss nun für jedes der angeschlossenen Geräte überprüft werden, ob es sich um ein \emph{ZigBit}-\emph{USB}-Stick
handelt. Hierzu wird an das Gerät ein Befehl gesendet, der zur Abfrage der Versionsnummer der verwendeten
\emph{Serialnet}-Firmware dient. Die Rückgabe wird nun mit dem erwarteten Wert verglichen. Hierzu wird das
\emph{python-serial}-Modul verwendet::

\begin{lstlisting}{frame=praktisch4}
import serial
def testDevice(self, deviceName):
    ret = []

    ## Versuch, eine Verbindung aufzubauen und die 
    ## Versionskennung der Serialnet-Firmware abzufragen. 
    try:
        ser = serial.Serial("/dev/%s" % deviceName, 38400, timeout=3)
        ser.write("ATI\r\n") ## ATI - Befehl zum Anfragen der
                             ## Versionsnummer
        out = ser.read(74)
        
        ## Wurde ueberhaupt eine Antwort empfangen? 
        if out:

            ## Antwort in Bestandteile zerlegen
            formatedOut = out.split("\r\n")

            ## Hat die Antwort das richtige Format?
            if len(formatedOut) == 5:
                vendor  = formatedOut[1]
                name    = formatedOut[2]
                version = formatedOut[3]
                mac     = formatedOut[4]

                ## Herstellerkennung und Modell ueberprufen
                if vendor == 'ATMEL' and name == 'ZIGBIT':

                    ## Ein ZigBit-Modul wurde erkannt
                    return (vendor, name, version, mac)
                else:

                    ## Es wurde kein ZigBit-Modul erkannt
                    return False
        else:
            ## Antwort hatte falsches Format -> Es handelt sich
            ## nicht um ein ZigBit-Modul
            return False

    ## Fehler beim Zugriff auf serielle Schnittstelle
    except serial.SerialException:
        return False
\end{lstlisting}

\subsection{CORBA-Anbindung}
Die \emph{CORBA}-Anbindung des \emph{MANVConnectors} an den \emph{MANVServer} erfolgt über
die in \cite{Jan} spezifizierten Interfaces. Dieses muss über den \emph{Java class Path}
eingebunden werden. Dies geschieht über den Parameter \emph{-cp} auf der Kommandozeile
der \emph{JVM} bzw. des \emph{Java-Compilers}. Der Connector schickt über die 
\emph{Server\_Incoming}-Schnittstelle eingehende Daten und Ereignisse an den \emph{MANVServer}.
Damit der \emph{MANVServer} umgekehrt auch Befehle an den \emph{MANVConnector} schicken kann,
muss dieser selbst die \emph{Connector\_Commands}-Schnittstelle implementieren. Dies
geschieht in der Klasse \emph{edu.kit.ibt.manv.connector.corba.CommandsImpl} (Eine
genaue Beschreibung der einzelnen Dateien, Klassen und Funktionalitäten findet sich in
Anhang~\label{anhang_beschreibung_software}).\\

Zur Lokalisierung der einzelnen \emph{CORBA}-Schnittstellen dient der \emph{CORBA-Nameserver}.
Die Adresse des Nameservers muss im voraus bekannt sein. Meist läuft dieser auf dem selben Rechner
wie der \emph{MANVServer}. Die Adresse wird beim Start des \emph{MANVConnectors} als 
Kommandozeilenparameter "`-ORBInitRef NameService"' übergeben\footnote{Wenn z.B. Nameserver, \emph{MANVServer}
und \emph{MANVConnector} auf dem selben Rechner laufen, so lautet der entsprechende Parameter:
"`-ORBInitRef NameService=corbaloc::localhost:1771/NameService"'.}. Die Verbindung zum Nameserver
wird nun beim Start des \emph{MANVConnectors} in der Methode \emph{initCORBA()} aufgebaut. 
Sobald diese hergestellt wird, wird nach der Adresse des \emph{MANVServers} gefragt. Dies geschieht über
eine Anfrage nach den Schnittstellen des Servers, also \emph{Server\_Incoming} und \emph{Server\_Control}. 
Zuletzt muss sich der \emph{MANVConnector} noch beim \emph{MANVServer} registrieren, damit dieser
weiss, an wen er zu sendende Befehle zustellen muss. Hierzu wird die Methode \emph{registerConnector()}
der \emph{Server\_Control}-Schnittstelle verwendet. Nach diesem Schritt ist die Initialisierung der
\emph{CORBA}-Anbindung abgeschlossen, und der \emph{CorbaSender}-Thread, der eingehende Ereignisse
an den \emph{MANVServer} sendet kann gestartet werden.
