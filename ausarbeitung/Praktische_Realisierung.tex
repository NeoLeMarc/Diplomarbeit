
%%%-----------------------------------------------UMSETZUNG/VORBEREITUNGEN-------------------------------------------------------------
\chapter{Praktische Realisierung des Sensornetzes}

\section{Firmware}
\subsection{Implementierung}
Die Firmware des Erste-Hilfe-Sensors wurde um einen Treiber für das ZigBit-Modul ergänzt. Die Firware wurde in der
Programmiersprache C geschrieben, und setzt direkt auf die Hardware des ADuC auf. Es wurde lediglich die von 
Rowley Crossworks angebotene Standardbibliothek verwendet, die einige praktische Funktionen wie Stringmanipulation,
einen Interrupthandler und einen fertigen Startup-Code bietet.

Die Entwicklung von Software für einen Microcontroller zeichnet sich durch die Abwesenheit eines Betriebssystems 
aus. Ein Großteil der Funktionalität, die man von der Entwicklung von Software für einen standard Mikrocomputer 
gewohnt ist, ist schlichtweg nicht vorhanden. Hier sind insbesondere eine automatische Speicherverwaltung sowie
Threads und Prozesse zu erwähnen. Da der Erste-Hilfe-Sensor viele Aufgaben gleichzeitig erfüllen muss, stellt 
dies eine ernst zu nehmende Herausforderung dar. Das Problem wurde durch ein Interrupt getriebenes Programmiermodell
gelöst.

Es werden folgende Interrupts verwendet:

Timer0: Dieser Timer-Interrupt führt die Patientenüberwachung durch. Die einzelnen Sensoren werden abgefragt,
und eine Analyse der empfangenen Daten wird durchgeführt.

Timer1: Dieser Interrupt führt einige periodische Aufgaben durch. Zunächst werden die am Sensor vorhandenen
Taster abgefragt (Alarm Stummschalten, Alarm manuell auslösen etc.). Danach wird überprüft, in welchem Zustand
der Sensor sich aktuell befindet, also z.B. ob ein Alarm aufgetreten ist, oder ob der Patient sich in einem
guten Zustand befindet. Abhängig hiervon werden nun LEDs und ein angeschlossener Piezzo-Summer geschaltet,
um den Zustand nach aussen zu signalisieren. Zu letzt wird noch überprüft, wann zuletzt eine Übertragung
des Zustands des Sensors an die MANVSuite erfolgt ist. Liegt dies länger als einen konfiguriertes Zeitintervall
zurück, so wird eine Übertragung des aktuellen Zustands veranlasst.

Ein weiteres Problem sind die sehr beschränkten Ressourcen des Mikrocontrollers. Insbesondere der Speicher ist
mit 16kB sehr knapp bemessen. 


\subsubsection{Zugriff auf UART}
Der ADuC verfügt über einen UART Interrupt, welcher eine Statusänderung des UARTs signalisiert. Im Register 
\textsl{COMIEN0} wird konfiguriert, welche Zustände über den Interrupt singnalisiert werden sollen. Tritt
nun einer dieser Zustände auf, so wird der UART Interrupt ausgelöst. Im Interrupthandler muss nun überprüft
werden, welches Ereigniss zum Auslösen des Interrupts geführt hat. Dies ist im Register \textsl{COMSTA0} 
gespeichert. Wichtig ist an dieser Stelle, dass auch mehrere Ereignisse gleichzeitig auftreten können. 
Dies muss im Interrupthandler berücksichtigt werden, da sonst Ereignisse verloren gehen können.

Das eigentliche Senden und Empfangen erfolgt über die beiden Register \textsl{COMRX} und \textsl{COMTX}.
Zum Senden wird hierzu ein einzelnes Zeichen in \textsl{COMTX} gelegt. Nun muss eine gewisse Zeit gewartet
werden, bis das Zeichen gesendet wurde, und das nächste Zeichen in \textsl{COMTX} gelegt werden kann.
FÜr das Empfangen wird das Register \textsl{COMRX} in analoger Weise verwendet werden. Ob das nächste
Zeichen empfangen bzw. gesendet werden kann, kann mit Hilfe der Bits \textsl{DR} ("`Data Ready"' - Daten liegen vor)
bzw. \textsl{TEMT} ("`Transmit Buffer empty"' - Daten können gesendet werden) bestimmt werden.

Die einfachste Methode wäre hierbei, in einer Schleife Busy-Waiting zu betreiben, und so lange zu warten,
bis sich eins der beiden Bits verändert. Dies wäre jedoch sehr aufwendig und würde den Mikrocontroller 
unnötig lange blockieren. Statt dessen wird der Zustand der beiden Register nur dann überprüft, wenn ein 
UART-Interrupt aufgetreten ist.

Zum Senden und Empfangen von Daten werden zwei Ringpuffer verwendet. Möchte ein Unterprogramm Daten senden,
so greift es nicht direkt auf die UART-Schnittstelle zu sondern legt diese Daten lediglich in den Sendepuffer.
Das eigentliche Senden wird nun vom UART-Interrupthandler durchgeführt; das Unterprogramm kann weiter arbeiten,
ohne auf das fertige Senden der Daten warten zu müssen.

Das Empfangen von Daten erfolgt analog. Jedesmal wenn ein Zeichen von der seriellen Schnitstelle empfangen
wurde, wird dieses in den Empfangspuffer gelegt. Das Abarbeiten des Empfangspuffer erfolgt nun als Idle-Task:
Immer dann, wenn der Mikrocontroller gerade keine anderen Aufgaben erfüllen muss, wird der Empfangspuffer
abgearbeitet und eventuell empfangene Befehle werden abgearbeitet. Dies kann natürlich jederzeit durch 
die Abarbeitung von Interrupts unterbrochen werden.


%\chapter{Praktische Realisierung der Respirationsdetektion}
%\section{Baselinewandering}
%\subsection{Vorbereiten der Hardware}
%\subsubsection{Anforderung an die Hardware}
%... 24 bit, kein HP etc....
%\subsubsection{Realisierung der Anforderungen}
%... hier kann ein Schaltplan eines 24bit-EKG verstärker rein, oder auch ein Bild von dem Gerät
%
%\subsection{Datenerfassung}
%... wie kommen die Daten an, wie müssen sie konvertiert werden...
%
%\subsection{Signalverarbeitung in Matlab}
%... eben das Matlabprog. mit evtl. Auszügen aus dem Quelltext (diese, wenn möglich in den Anhang verfrachten und einen Hinweis darauf geben)
%
%
%\section{HRV-Variation}
%\subsection{Anforderung an die Hardware}
%... hier gibts nicht viele, und gerade das dann sagen, dass es mit fast jedem Gerät möglich wäre...
%
%\subsection{Datenerfassung}
%...
%
%\subsection{Signalverarbeitung in Matlab}
%...
%
%\section{QRS-Komplexe}
%\subsection{Anforderung an die Hardware}
%... wie oben
%
%\subsection{Datenerfassung}
%...
%
%\subsection{Signalverarbeitung in Matlab}
%
%\section{Referenzmessung}
%Hier nur kurze Erläuterung des Verfahrens
