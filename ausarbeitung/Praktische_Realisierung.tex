
%%%-----------------------------------------------UMSETZUNG/VORBEREITUNGEN-------------------------------------------------------------
\chapter{Praktische Realisierung des Sensornetzes}\label{Implementierung}

In diesem Kapitel wird die Implementierung des Sensornetzes, dabei auftretende Probleme sowie deren Lösungen, beschreiben.

\section{Hardware}
Nachfolgend wird die praktische Umsetzung der zwei verschiedenen Hardwarekomponenten, also des \emph{MANV-USB-Sticks} und der
\emph{MANVNode} beschrieben. In beiden Fällen musste hierzu ein \emph{ZigBit}-Modul mit einer anderen 
Hardwarekomponente verbunden werden. Dies kann grundsätzlich entweder über \emph{SPI} oder \emph{UART} erfolgen.
Bei \emph{SPI} handelt es sich um einen seriellen Bus, der besonders im Bereich der Mikrocontroller verbreitet ist,
und zur Anbindung von weiterer Peripherie dient. \emph{UART} war hingegen vor allem als serielle Schnittstellen
an \emph{PCs} verbreitet, und wurde hauptsächlich für die Anbindung von Modems verwendet. Heutzutage wurde diese
Schnittstelle weitestgehend von \emph{USB} verdrängt. Beim Einsatz der \emph{SerialNet}-Firmware scheidet die
Anbindung über \emph{SPI} jedoch aus, da dies von der Firmware nicht unterstützt wird.

\subsection{Anbindung des ZigBit-Moduls an den USB-Port}
\nomenclature{IC}{Integrierter Schaltkreis}
Zur Realisierung des \emph{USB-Sticks} bietet sich die Verwendung des \emph{UARTs} an, da eine breite Palette 
von fertigen \emph{ICs} zur Verfügung steht, mit deren Hilfe ein \emph{UART} an einen \emph{USB-Bus} angebunden werden 
kann. Auf Seiten des Betriebssystems präsentiert sich der \emph{IC} wie ein serieller Port und kann softwareseitig
wie ein solcher angesprochen werden. Die Firma \emph{Embedded Projects} bietet mit der \emph{USB-UART-Bridge}
eine fertige Lösung an, auf der ein entsprechender \emph{IC}, ein Spannungsregler für 3.3~V-Versorgungsspannung
sowie ein \emph{USB-Anschluss} bereits integriert sind. Das \emph{ZigBit}-Modul wird nun auf die in 
Abbildung~\ref{platine_usbstick} dargestellte Platine aufgelötet. Diese Platine kann nun selbst mit Hilfe einer
Stiftleiste huckepack auf die \emph{USB-UART-Bridge} aufgelötet werden, um die nötige Formstabilität zu erhalten.

\subsection{Herstellung und Bestückung der Platine der \emph{MANVNode}}
\Abbildungps{!htb}{0.75}{diagramme/usbstick_makro.png}{usbstick}{\emph{MANV-USB-Stick}.}
\Abbildungps{!htb}{1}{diagramme/manvnode.jpg}{manvnode}{Fertig bestückte Platine der \emph{MANVNode.}}
\nomenclature{nF}{Nanofarad}
\nomenclature{Flashen}{Programmieren eines Flashspeichers.}
\nomenclature{Lötstopplack}{Auf Leiterplatten aufgetragene Lackschicht, die die Leiterbahnen schützt.}
Auch bei der \emph{MANVNode} erfolgt eine Anbindung des \emph{ZigBit}-Moduls über \emph{UART}. Hierbei muss
beachtet werden, dass der \emph{UART} auch für das Flashen des Microcontrollers benötigt wird. Daher verfügt
die Platine über eine Reihe von Jumpern, mit denen das \emph{ZigBit}-Modul vom \emph{UART} abgetrennt werden
kann.\\
        \\
Der \emph{ADuC-7026-Mikrocontroller} benötigt drei 470~nF-Kondensatoren zur Stabilisierung der
Stromversorgung. Diese waren in den ersten beiden Versionen der Platine zu weit vom \emph{Mikrocontroller} entfernt 
aufgebracht worden, was dazu führte, dass der \emph{Mikrocontroller} beim Flashvorgang, dazu neigte, spontan 
abzustürzen. Dieser Fehler konnte durch die Verringerung des Abstandes zwischen Mikrocontroller und 
Kondensatoren behoben werden.


\section{Firmware}
Die Firmware des Erste-Hilfe-Sensors wurde um einen Treiber für das \emph{ZigBit}-Modul ergänzt. Die \emph{Firmware}
wurde in der Programmiersprache \emph{C} geschrieben, und setzt direkt auf die Hardware des \emph{ADuC} auf. Es wurde 
lediglich die von \emph{Rowley Crossworks} angebotene Standardbibliothek verwendet, die einige praktische Funktionen wie
Stringmanipulation, einen Interrupthandler und einen fertigen \emph{Startup-Code} bietet.
Die Entwicklung von Software für einen Microcontroller zeichnet sich durch die Abwesenheit eines Betriebssystems 
aus. Ein Großteil der Funktionalität, die man von der Entwicklung von Software für einen gewöhnlichen Mikrocomputer 
gewohnt ist, ist schlichtweg nicht vorhanden. Hier sind insbesondere eine automatische Speicherverwaltung sowie
\emph{Threads} und \emph{Prozesse} zu \emph{erwähnen}. Da der \emph{Erste-Hilfe-Sensor} viele Aufgaben gleichzeitig 
erfüllen muss, stellt dies eine ernst zu nehmende Herausforderung dar. Das Problem wurde durch ein
\emph{Interrupt}-getriebenes Programmiermodell gelöst. Zu beachten sind hierbei die sehr beschränkten Ressourcen
des \emph{Mikrocontrollers}. Insbesondere der Speicher ist mit 16~kB sehr knapp bemessen. 

\subsection{Verwendete Interrupts}
\nomenclature{Crossworks}{Entwicklungsumgebung für \emph{Mikrocontroller-Firmware}.}
\nomenclature{Interrupt}{Unterbrechungsaufforderung. Die Abarbeitung des aktuellen Programmcodes wird sofort beendet,
                         und eine \emph{ISR} wird ausgeführt.}
\nomenclature{Startup-Code}{Programmcode, der die Initialisierung eines \emph{Mikrocontrollers} durchführt.}
Es werden folgende \emph{Interrupts} verwendet:

\emph{Timer0}: Dieser \emph{Timer-Interrupt} führt die Patientenüberwachung durch. Die einzelnen Sensoren werden abgefragt,
und eine Analyse der empfangenen Daten wird durchgeführt.

\nomenclature{Piezo-Summer}{Elektrisches Bauteil, dass einen Summton generiert, sobald man eine Spannung anlegt.}
\emph{Timer1}: Dieser \emph{Interrupt} führt einige periodische Aufgaben durch. Zunächst werden die am Sensor vorhandenen
Taster abgefragt (Alarm stumm schalten, Alarm manuell auslösen etc.). Danach wird überprüft, in welchem Zustand
der Sensor sich aktuell befindet, also z.B. ob ein Alarm aufgetreten ist oder ob der Patient sich in einem
guten Zustand befindet. Abhängig hiervon werden nun \emph{LEDs} und ein angeschlossener \emph{Piezo}-Summer geschaltet,
um den Zustand nach außen zu signalisieren. Zuletzt wird noch überprüft, wann zuletzt eine Übertragung
des Zustands des Sensors an die \emph{MANVSuite} erfolgt ist. Liegt dies länger als ein konfiguriertes Zeitintervall
zurück, so wird eine Übertragung des aktuellen Zustands veranlasst. Ein sinnvolle Länge für dieses Zeitintervall
ist ein Wert von 5-10~s.

\subsubsection{Zugriff auf UART}
Der \emph{ADuC} verfügt über einen \emph{UART-Interrupt}, welcher eine Statusänderung des \emph{UARTs} signalisiert. 
Im Register \emph{COMIEN0} wird konfiguriert, welche Zustände über den \emph{Interrupt} signalisiert werden sollen. Tritt
nun einer dieser Zustände auf, so wird der \emph{UART-Interrupt} ausgelöst. In der \emph{ISR} muss nun überprüft
werden, welches Ereignis zum Auslösen des \emph{Interrupts} geführt hat. Diese Information ist im Register \emph{COMSTA0} 
gespeichert. Wichtig ist an dieser Stelle, dass auch mehrere Ereignisse gleichzeitig auftreten können. 
Dies muss in der \emph{ISR} berücksichtigt werden, da sonst Ereignisse verloren gehen können.

Das eigentliche Senden und Empfangen erfolgt über die beiden Register \emph{COMRX} und \emph{COMTX}.
Zum Senden wird hierzu ein einzelnes Zeichen in \emph{COMTX} gelegt. Nun muss eine gewisse Zeit gewartet
werden, bis das Zeichen gesendet wurde und das nächste Zeichen in \emph{COMTX} gelegt werden kann.
Für das Empfangen wird das Register \emph{COMRX} in analoger Weise verwendet. Ob das nächste
Zeichen empfangen bzw. gesendet werden kann, kann mit Hilfe der Bits \emph{DR} (\emph{"`Data Ready"'} - Daten liegen vor)
bzw. \emph{TEMT} (\emph{"`Transmit Buffer empty"'} - Daten können gesendet werden) bestimmt werden.

Die einfachste Methode wäre hierbei, in einer Schleife \emph{Busy-Waiting} zu betreiben und so lange zu warten,
bis sich eins der beiden Bits verändert. Dies wäre jedoch sehr aufwendig und würde den \emph{Mikrocontroller}
unnötig lange blockieren. Statt dessen wird der Zustand der beiden Register nur dann überprüft, wenn ein 
\emph{UART-Interrupt} aufgetreten ist.

Zum Senden und Empfangen von Daten werden zwei Ringpuffer verwendet. Möchte ein Unterprogramm Daten senden,
so greift es nicht direkt auf die \emph{UART}-Schnittstelle zu, sondern legt diese Daten lediglich in den Sendepuffer.
Das eigentliche Senden wird nun vom \emph{UART-Interrupthandler} durchgeführt; das Unterprogramm kann weiter arbeiten,
ohne auf das fertige Senden der Daten warten zu müssen.

\nomenclature{Idle Task}{Aufgabe, die immer dann bearbeitet wird, wenn keine anderen Aufgaben anstehen.}
Das Empfangen von Daten erfolgt analog. Jedesmal, wenn ein Zeichen von der seriellen Schnitstelle empfangen
wurde, wird dieses in den Empfangspuffer gelegt. Das Abarbeiten des Empfangspuffers erfolgt nun als \emph{Idle-Task}:
Immer dann, wenn der \emph{Mikrocontroller} gerade keine anderen Aufgaben erfüllen muss, wird der Empfangspuffer
abgearbeitet und eventuell empfangene Befehle werden ausgeführt. Dies kann natürlich jederzeit durch 
die Behandlung von \emph{Interrupts} unterbrochen werden.

\section{MANVConnector}

Die folgenden Abschnitte beschreiben, wie der Zugriff vom \emph{MANVConnector} auf den \emph{MANV-USB-Stick} 
konkret erfolgt. Der \emph{MANV-USB-Stick} verhält sich hierbei dem Betriebssystem gegenüber wie eine serielle 
Schnittstelle.

\nomenclature{Socket}{Softwareabstraktion einer Netzwerkverbindung die sich verhält wie ein Dateizugriff.}
\subsection{Zugriff auf die serielle Schnittstelle}
Der Zugriff auf die serielle Schnittstelle mittels Java bringt einige praktische Probleme mit sich.
Der \emph{Java}-Standard bietet von Haus aus keine Möglichkeit, auf die serielle Schnittstelle zuzugreifen.
Zwar gibt es einzelne Lösungen von Dritt\-an\-bie\-tern wie z.B. \emph{RxTx} oder \emph{JavaComm}, allerdings
sind diese meist plattformabhängig und funktionieren meist nur auf wenigen Betriebssystemen. Da die
in dieser Diplomarbeit entworfene Lösung auf möglichst vielen Betriebssystemen einsetzbar sein soll, 
wurde entschieden, den Zugriff auf die serielle Schnittstelle stattdessen in einem austauschbaren
Modul zu kapseln. Der Zugriff auf das Modul erfolgt über eine \emph{Socketverbindung}, welche in \emph{Java}
standardmäßig verfügbar ist. Das Modul kann nun in jeder beliebigen Programmiersprache implementiert
werden. Es ist z.B. möglich, für verschiedene Betriebssysteme verschiedene Module anzubieten.
Für die Zwecke dieser Diplomarbeit wurde beispielhaft ein Modul für \emph{UNIX} in der Programmiersprache
Python implementiert, welche unter vielen \emph{UNIX}-artigen Betriebssystemen wie \emph{Linux}, \emph{MacOS}, 
\emph{BSD} und co.  bereits zur Standardinstallation gehört. Lediglich das \emph{PySerial}-Modul muss nachinstalliert werden.
% TODO: Hier Zitat des PySerial Moduls

\begin{lstlisting}{Seriellen Port auf Socket umleiten}
#!/usr/bin/env python -OO
# MANV-Sensor - Serial to socket
# for Java to ZigBit connector 

PORT = 4711 ## Port fuer Socketverbindung.
import serial, socket, select, sys, SocketServer, time

class MANVSerialToSocketHandler(SocketServer.\
        BaseRequestHandler):

    def handle(self):
        ## Handler-Hook, in den der SocketServer einsteigt
        print "Connection to socket opened"
        self.openSerial()

        print "Serial connected"
        self.tunnel()

    def openSerial(self):
        ## Serielle Schnittstelle oeffnen.
        ## Welche das genau ist, wird auf der Kommandozeile  
        ## als Parameter uebergeben.
        self.serial = serial.Serial(sys.argv[1], 38400, 
                                    timeout=1)

    def shutdown(self):
        ## Socket-Verbidung wird geschlossen -> aufraeumen
        self.serial.close()

    def tunnel(self):
        ## Weiterleiten von Daten:
        ## Socket -> Serial
        ## Serial -> Socket
        end = False
        print "Entering tunnel mode"

        while not end:
            ## Select verwenden, um socket und seriellen  
            ## Port ressourcensparend zu ueberwachen. 
            ## Funktioniert leider nur unter UNIX.
            readylist = select.select((self.request, 
                                       self.serial),
                                       (), ())

            ## Behandeln aller empfangenen Daten
            for readysocket in readylist[0]:

                ## Fallunterscheidung zwischen seriellem 
                ## Port und Socket, da hier die 
                ## Semantik unterschiedlich ist.
                if readysocket == self.serial:

                    ## Daten  wurden auf seriellem Port 
                    ## empfangen -> auf socket schreiben.
                    data = self.serial.read(1024)
                    self.request.send(data)

                elif readysocket == self.request:

                    ## Daten wurden auf Socket empfangen
                    ## -> auf seriellen Port schreiben
                    data = self.request.recv(1024)

                    if data:
                        self.serial.write(data)

                    else:
                        ## EOF empfangen -> shutdown
                        end = True

                ## select hat etwas zurueck geliefert, das 
                ## weder Socket noch serieller Port ist
                ## -> shutdown
                else:
                    data = ""
                    end = True

                ## Daten zu Debuggingzwecken auf Konsole 
                ## ausgeben.
                print data

        ## Aufraeumen: Seriellen Port schliessen 
        self.serial.close()
        self.request.close()
        print "Leaving tunnel mode"


class ReusableServer(SocketServer.TCPServer):

    def server_bind(self):
        ## Socket wiederverwendbar machen.
        ## Wenn man das nicht tut, ist er nach Beenden 
        ## des Programms fuer 5 Minuten nicht ansprechbar.
        self.socket.setsockopt(socket.SOL_SOCKET,
                               socket.SO_REUSEADDR, 1)
        self.socket.bind(self.server_address)

## Einstiegspunkt 
if __name__ == '__main__':
      server = ReusableServer(('localhost', PORT), 
                              MANVSerialToSocketHandler)
      server.serve_forever()
\end{lstlisting}

\nomenclature{Port}{Schnittstelle}
Für die Überwachung von \emph{Socket} und seriellem \emph{Port} wird in diesem Programm der Systemaufruf
\emph{select()} verwendet. Wird dieser aufgerufen, gibt das Programm so lange den \emph{Prozessor}
für andere Programme frei, bis Daten empfangen wurden. Sobald dies der Fall ist, kehrt
der \emph{select()}-Aufruf zurück und liefert eine Liste mit allen Quellen, von denen Daten
empfangen wurden. Diese können nun mit den entsprechenden Aufrufen von \emph{recv()} 
(im Falle von \emph{Sockets}) bzw. \emph{read()} (für den seriellen \emph{Port}) abgeholt werden.
Diese Lösung funktioniert jedoch in dieser Form nur unter \emph{UNIX}. Unter \emph{Windows} steht der 
\emph{select()}-Aufruf zwar zur Verfügung, jedoch ist es hier nicht möglich, diesen zur
Überwachung des seriellen \emph{Ports} zu verwenden. Das obige Programm lässt sich hier jedoch
recht einfach durch die Verwendung von \emph{Threads} anpassen, indem für jede Richtung (also
Seriell$\,\rightarrow{}\,$\emph{Socket} und \emph{Socket}$\,\leftarrow{}\,$Seriell) jeweils ein eigener \emph{Thread} verwendet
wird. Alternativ empfiehlt sich eine Implementierung mit Hilfe der Programmiersprache \emph{C++}.

\subsection{Automatische Erkennung des \emph{ZigBit-USB-Sticks}}\label{usb_stick_erkennen}
\nomenclature{Bus}{Verbindung zwischen mehreren Geräten, bei denen alle Geräte an einen gemeinsamen Übertragungsweg
                   angeschlossen sind.}  
Bei der Verwendung von \emph{USB}-Geräten stellt sich bei vielen Betriebssystemen das Problem,
dass die Benennung bei jedem Einstecken des Gerätes anders sein kann. Dies kann insbesondere
dann auftreten, wenn mehrere gleichartige Geräte am \emph{USB-Bus} (z.B. mehrere 
\emph{USB-Serial}-Geräte) vorhanden sind. Um nicht nach jedem Einsteckvorgang oder Neustart des Betriebssystems die
Konfiguration des \emph{MANV-Connectors} anpassen zu müssen, wird der Name des \emph{USB}-Sticks
nicht fest konfiguriert, sondern stattdessen eine automatische Erkennung durchgeführt.
Unter \emph{Linux} stehen mit \emph{libusb} und dem \emph{/sys}-Dateisystem zwei geeignete Werkzeuge
zur Verfügung, um diese Erkennung durchzuführen.\\
Zunächst werden mit Hilfe der \emph{libusb} alle \emph{USB-Busse} nach dem auf dem \emph{ZigBit}-\emph{USB-Stick}
verwendeten \emph{IC} vom Typ \emph{cp210x} durchsucht. Dieser hat die Herstellerkennung \emph{0x10C4} und die
Produktkennung \emph{0xEA60}. Unter Python steht mit \emph{python-usb} eine geeignete Schnittstelle zu
\emph{libusb} zur Verfügung.

\begin{lstlisting}{USB-Bus durchsuchen}
import usb
def searchUSB(self):

    ## Durchsuchen alle USB-Busse 
    for bus in usb.busses():

        ## Durchsuchen aller Geraete dieses Busses
        for dev in bus.devices:

            ## Betrachten der Vendor-ID und der Produkt-ID
            if dev.idVendor == 0x10c4 and \
               dev.idProduct == 0xea60:
               
                ## Ein entsprechendes Geraet wurde 
                ## gefunden wir geben dieses 
                ## zurueck 
                return (bus.dirname, dev.filename)
   
    print "No devices found on USB-Bus."
    return False
\end{lstlisting}

Wenn am \emph{USB-Bus} kein entsprechendes Gerät gefunden wurde, kann bereits jetzt die Suche abgebrochen werden.
Wird jedoch ein passendes Gerät gefunden, müssen zunächst alle passenden \emph{Device-Nodes}\footnote{Unter UNIX
verhalten sich Hardwaregeräte grundsätzlich wie Dateien und finden sich daher im Dateisystem unterhalb
des Verzeichnisses \emph{/dev} als virtuelle Datei wieder. Eine solche Datei wird als \emph{Device-Node} bezeichnet.} im
\emph{/dev}-Verzeichnis gefunden werden. Hierzu bietet sich eine Suche im \emph{/sys}-Dateisystem an. Hierfür sind keine
externen Module notwendig, es können die normalen Dateisystem-Operationen des \emph{OS}-Moduls verwendet werden:

\begin{lstlisting}{Devicenode lokalisieren}
import os
def searchSYS(self):

    ## Suchen aller usb-serial-Geraete ueber /sys 
    devices = []

    for device in \
        os.listdir('/sys/bus/usb-serial/devices'):
        ## Alle Geraete in Rueckgabe einfuegen
        devices.append(device)

    return devices
\end{lstlisting}

\nomenclature{Debuggen}{Suchen und Entfernen von Fehlern.}
Da an den \emph{USB-Bus} beliebige \emph{USB-Serial}-Geräte angeschlossen sein können\footnote{Während der Entwicklung
was es nicht ungewöhnlich, dass bis zu 3 Geräte angeschlossen waren: Bei einem handelte es sich um den
\emph{ZigBit-USB-Stick}, zwei weitere dienten zum \emph{Flashen} und \emph{Debuggen} der angeschlossenen 
\emph{Mikrocontroller}.}, 
muss nun für jedes der angeschlossenen Geräte überprüft werden, ob es sich um einen \emph{ZigBit}-\emph{USB}-Stick
handelt. Hierzu wird an das Gerät ein Befehl gesendet, der zur Abfrage der Versionsnummer der verwendeten
\emph{Serialnet}-Firmware dient. Die Rückgabe wird nun mit dem erwarteten Wert verglichen. Hierzu wird das
\emph{python-serial}-Modul verwendet:

\begin{lstlisting}{ZigBit-Modul erkennen}
import serial
def testDevice(self, deviceName):
    ret = []

    ## Versuch, eine Verbindung aufzubauen und die 
    ## Versionskennung der Serialnet-Firmware abzufragen. 
    try:
        ser = serial.Serial("/dev/%s" % deviceName, 38400,\
                            timeout=3)
        ser.write("ATI\r\n") ## ATI - Befehl zum Anfragen
                             ## der Versionsnummer
        out = ser.read(74)
        
        ## Wurde ueberhaupt eine Antwort empfangen? 
        if out:

            ## Antwort in Bestandteile zerlegen
            formatedOut = out.split("\r\n")

            ## Hat die Antwort das richtige Format?
            if len(formatedOut) == 5:
                vendor  = formatedOut[1]
                name    = formatedOut[2]
                version = formatedOut[3]
                mac     = formatedOut[4]

                ## Herstellerkennung und Modell ueberprufen
                if vendor == 'ATMEL' and name == 'ZIGBIT':

                    ## Ein ZigBit-Modul wurde erkannt
                    return (vendor, name, version, mac)
                else:

                    ## Es wurde kein ZigBit-Modul erkannt
                    return False
            else:
                ## Antwort hatte falsches Format -> Es 
                ## handelt sich nicht um ein 
                ## ZigBit-Modul
                return False

        else:
            ## Keine Antwort empfangen
            return False

    ## Fehler beim Zugriff auf serielle Schnittstelle
    except serial.SerialException:
        return False
\end{lstlisting}

\subsection{CORBA-Anbindung}
\Abbildungps{!htb}{0.5}{diagramme/corba.pdf}{corba}{Komponentendiagramm der \emph{CORBA}-Schnittstellen. (Quelle: Jan Tepelmann)}
\nomenclature{Nameserver}{Softwaredienst, der eine Übersetzung von Namen in Adressen vornimmt.}
Die \emph{CORBA}-Anbindung des \emph{MANVConnectors} an den \emph{MANVServer} erfolgt über
die in \cite{Jan} spezifizierten \emph{Interfaces}. Diese müssen über den \emph{Java Classpath}
eingebunden werden. Dies geschieht über den Parameter \emph{-cp} auf der Kommandozeile
der \emph{JVM} bzw. des \emph{Java-Compilers}. Der \emph{Connector} schickt über die 
\emph{Server\_Incoming}-Schnittstelle eingehende Daten und Ereignisse an den \emph{MANVServer}.
Damit der \emph{MANV\-Server} umgekehrt auch Befehle an den \emph{MANVConnector} schicken kann,
muss dieser selbst die \emph{Connector\_Commands}-Schnittstelle implementieren. Dies
geschieht in der Klasse \emph{CommandsImpl}\footnote{Eine
genaue Beschreibung der einzelnen Dateien, Klassen und Funktionalitäten findet sich in
Anhang~\label{anhang_beschreibung_software}.}.\\

Zur Lokalisierung der einzelnen \emph{CORBA}-Schnittstellen dient der \emph{Nameserver}.
Die Adresse des Nameservers muss im Voraus bekannt sein. Meist läuft dieser auf dem selben Rechner
wie der \emph{MANVServer}. Die Adresse wird beim Start des \emph{MANVConnectors} als 
Kommandozeilenparameter "`--ORBInitRef NameService"' übergeben\footnote{Wenn z.B. Nameserver, \emph{MANVServer}
und \emph{MANVConnector} auf dem selben Rechner laufen, so lautet der entsprechende Parameter:
"`--ORBInitRef NameService=corbaloc::localhost:1771/NameService"'.}. Die Verbindung zum \emph{Nameserver}
wird nun beim Start des \emph{MANVConnectors} in der Methode \emph{initCORBA()} aufgebaut. 
Sobald diese hergestellt wird, wird nach der Adresse des \emph{MANVServers} gefragt. Dies geschieht über
eine Anfrage nach den Schnittstellen des Servers, also \emph{Server\_Incoming} und \emph{Server\_Control}. 
Zuletzt muss sich der \emph{MANVConnector} noch beim \emph{MANVServer} registrieren, damit dieser
weiß, an wen er zu sendende Befehle zustellen muss. Hierzu wird die Methode \emph{registerConnector()}
der \emph{Server\_Control}-Schnittstelle verwendet. Nach diesem Schritt ist die Initialisierung der
\emph{CORBA}-Anbindung abgeschlossen, und der \emph{CorbaSender}-Thread, der eingehende Ereignisse
an den \emph{MANVServer} sendet, kann gestartet werden.
